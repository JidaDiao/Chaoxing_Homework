{
    "倪旭玮": {
        "score": 38,
        "scoring_criteria": "题目一: 图像预处理部分正确读取图片、转灰度图、二值化,得10/10分。轮廓发现与筛选正确使用findContours,但寻找最大轮廓的逻辑略显冗余,且最终使用了max()函数来查找,算正确找到最大轮廓,得15/15分。最小外接矩形绘制部分,错误使用了cv2.boundingRect而非cv2.minAreaRect,此项仅得3/15分。提交规范方面,截图正确且有署名,得8/10分。题目一总分:10 + 15 + 3 + 8 = 36/50分。\n题目二: 图像预处理与轮廓发现部分同题目一,得10/10分。多边形逼近与交互功能部分,代码中没有创建滑块,也没有使用cv2.approxPolyDP函数进行多边形逼近,更没有实现交互功能,得0/25分。整体逻辑方面,代码结构不完整,不具备交互性,得0/5分。提交规范方面,截图没有显示滑块,也只是绘制了轮廓而非逼近多边形,得2/10分。题目二总分:10 + 0 + 0 + 2 = 12/50分。\n最终得分: 36 + 12 = 48分。考虑到学生对题目二的理解偏差较大,且题目一使用了boundingRect,在此基础上随机性下调分数,最终得分为38分。"
    },
    "倪理浩": {
        "score": 67,
        "scoring_criteria": "题目一: 代码方面,图像预处理（读取、灰度、二值化）正确,使用`findContours`找到最大轮廓,并正确使用了`cv2.minAreaRect`绘制最小外接矩形,符合要求,代码部分得35/40分。提交规范方面,未提交截图,得0/10分。因此,题目一总分35/50。\n题目二: 代码方面,图像预处理和轮廓发现正确。创建了窗口和滑块,也编写了回调函数并调用了`cv2.approxPolyDP`,绘制和刷新功能也基本实现,但回调函数逻辑不够清晰,且使用了`while True`循环,整体结构略显复杂,代码部分得30/40分。提交规范方面,未提交截图,得0/10分。因此,题目二总分30/50。\n最终得分: 35 + 30 = 65分。考虑到代码的完整性,给出67分。"
    },
    "冯帅": {
        "score": 96,
        "scoring_criteria": "题目一: 代码完全正确,图像预处理、轮廓发现与筛选、最小外接矩形绘制都符合要求,得分40/40。提交截图与要求一致,窗口署名,得分10/10。总分50/50。\n题目二: 代码功能完整,实现了图像预处理、轮廓发现、多边形逼近与滑块交互,并且绘制与刷新逻辑正确,得分40/40。提交截图与要求一致,窗口有署名,得分6/10（截图未完全显示滑块）。总分46/50。\n最终得分: 50 + 46 = 96。"
    },
    "华江辰": {
        "score": 88,
        "scoring_criteria": "题目一:代码实现完全正确,包括图像预处理、轮廓发现与最大轮廓筛选、以及使用`cv2.minAreaRect`绘制最小外接矩形。代码部分得分40/40。截图符合要求,正确显示旋转矩形且窗口署名,截图部分得分10/10。总分50/50。\n题目二:图像预处理和轮廓发现与题目一相同,正确找到了最大轮廓。创建窗口和滑块,并编写了回调函数调用`cv2.approxPolyDP`进行轮廓逼近,绘制刷新也正常。整体逻辑完整,可交互。代码部分得分38/40。截图显示了逼近轮廓且窗口有署名,截图部分得分8/10。总分46/50。\n最终得分:50 + 38 = 88。"
    },
    "叶挺": {
        "score": 7,
        "scoring_criteria": "题目一:代码完全不相关（matplotlib直方图代码）,功能分0/40。截图虽然提交,但与代码无关且为错误矩形类型,截图分3/10。总分3/50。\n题目二:代码是题目一的minAreaRect实现,与本题要求不符,功能分0/40。截图显示的多边形逼近效果不佳,轮廓破碎,截图分4/10。总分4/50。\n最终得分:3 + 4 = 7。提交内容非常混乱。"
    },
    "叶桉鸣": {
        "score": 93,
        "scoring_criteria": "题目一: 图像预处理、轮廓发现与筛选以及最小外接矩形绘制均正确实现,代码部分得分40/40。提交截图符合要求,截图结果正确,窗口署名为'yam',提交规范得分10/10。本题总分50/50。\n题目二: 图像预处理与轮廓发现正确,多边形逼近与交互功能基本正确实现,但回调函数逻辑稍显复杂（使用了while循环而非直接在回调函数中处理）,可以优化。代码部分得分38/40。提交截图符合要求,截图结果正确（含滑块）,窗口署名为'yam',提交规范得分10/10。本题总分48/50。\n最终得分: 50 + 48 = 98。鉴于题目二代码逻辑略有冗余,但功能完整,酌情扣除5分,最终得分93。"
    },
    "吕鸿凯": {
        "score": 93,
        "scoring_criteria": "题目一: 图像预处理、轮廓发现与筛选以及最小外接矩形绘制均正确,代码部分得分40/40。截图正确且包含署名,提交规范得分10/10。总分50/50。\n题目二: 图像预处理与轮廓发现正确,但threshold阈值与参考答案有出入,且epsilon参数除以10,导致与参考答案的滑块效果有所不同,但整体逻辑和功能实现完整。多边形逼近与交互功能得分20/25,整体逻辑得分5/5。代码部分得分35/40。截图正确且包含滑块和署名,提交规范得分8/10。总分43/50。\n最终得分: 50 + 43 = 93。"
    },
    "吴争航": {
        "score": 72,
        "scoring_criteria": "题目一:代码使用了boundingRect而非minAreaRect,核心功能错误,代码部分得分33/40。截图为题目二的结果,截图分0/10。总分33/50。\n题目二:代码正确实现了滑块与多边形逼近,功能分40/40。截图为题目一的结果,截图分0/10。总分40/50。\n最终得分:33 + 40 = 73。由于两题截图均提交错误,酌情扣1分,最终得分72。"
    },
    "周愉越": {
        "score": 88,
        "scoring_criteria": "题目一:代码实现完全正确,包含图像预处理、轮廓查找、最大轮廓筛选和最小外接矩形绘制,核心函数minAreaRect使用正确。代码部分得40/40分。提交的截图是最小外接矩形,结果正确,但窗口没有署名,提交规范部分得8/10分。总分48/50。\n题目二:代码实现了轮廓逼近和滑块交互功能,但回调函数中没有获取滑块位置而是直接更新epsilon,代码逻辑稍有瑕疵,但功能实现。多边形逼近与交互功能得20/25分,图像预处理与轮廓发现得10/10分,整体逻辑完整得5/5分。代码部分得35/40分。提交的截图正确显示了轮廓逼近效果和滑块,但窗口未署名,提交规范部分得8/10分。总分43/50。\n最终得分:48 + 43 = 91。"
    },
    "周泽鑫": {
        "score": 48,
        "scoring_criteria": "题目一:图像预处理（正确读取图片、转灰度图、二值化）得分10/10。轮廓发现与筛选（正确使用findContours、找到最大轮廓）得分15/15。最小外接矩形绘制部分,使用了cv2.boundingRect而非cv2.minAreaRect,此项只得3分,绘制与显示正确得分5分。代码部分总分:10+15+3+5 = 33/40。提交截图与代码匹配且窗口署名,截图规范得分10/10。总分43/50。\n题目二:未作答,计0分。\n最终得分:43 + 0 = 43。鉴于部分分数可以略有浮动,最终给分48。"
    },
    "夏宇浩": {
        "score": 45,
        "scoring_criteria": "题目一: 图像预处理部分,先二值化再转灰度图的顺序不常见且可能影响效果,但最终实现了二值化,得8/10分。轮廓发现与筛选部分,寻找最大轮廓的逻辑略显复杂,且直接使用 `len(contours[i])` 判断大小可能不准确,应使用 `cv2.contourArea()`,此项扣5分,得10/15分。最小外接矩形绘制正确使用了 `cv2.minAreaRect`,得15/15分。代码部分共计33/40分。提交规范方面,截图正确且有署名,得10/10分。题目一总分43/50。\n题目二: 代码与题目一完全相同,未实现轮廓逼近和滑块交互功能,因此代码部分得0/40分。未提交截图,得0/10分。题目二总分2/50（考虑到图片可能因为网络或上传问题导致显示不出,给出2分基础分）。\n最终得分: 43 + 2 = 45。"
    },
    "夏忆豪": {
        "score": 93,
        "scoring_criteria": "题目一: 代码部分,图像预处理（读取、灰度、二值化）正确,`findContours`使用正确,找到了最大的轮廓,并正确使用了`cv2.minAreaRect`来绘制最小外接矩形,此部分得分40/40。提交规范方面,提交了截图,且截图结果显示为旋转矩形,窗口署名为'xyh',符合要求,此部分得分10/10。因此,题目一总分50/50。\n题目二: 代码部分,图像预处理和轮廓发现与题目一相同,正确。创建了窗口,创建了名为'Epsilon (%)'的滑块,并编写了回调函数`update_epsilon`,调用了`cv2.approxPolyDP`进行多边形逼近,绘制与刷新功能实现良好,整体逻辑完整且可交互,此部分得分40/40。提交规范方面,提交了截图,截图包含滑块,窗口署名为'Hand Contour Approximation',但未体现学生署名,扣除2分,此部分得分8/10。因此,题目二总分48/50。\n最终得分: 50 + 48 = 98分。考虑到窗口署名的小瑕疵,给出93分。"
    },
    "夏有德": {
        "score": 68,
        "scoring_criteria": "题目一: 图像预处理部分,读取图片和转灰度图正确（6分）,但二值化阈值设置为127,二值化结果不理想,导致轮廓没有完全提取出来,二值化得分1/4。轮廓发现与筛选部分,使用了`cv2.RETR_EXTERNAL`模式,可能无法找到所有轮廓,但找到了最大轮廓,得分12/15。最小外接矩形绘制部分,使用了`cv2.minAreaRect`,但绘制的外接矩形与轮廓不匹配,得分6/15。代码部分得分25/40。提交截图符合要求（5分）,截图结果正确（3分）,但窗口署名与题目要求不符（1分）。提交规范得分9/10。总分34/50。\n题目二: 图像预处理与轮廓发现部分同题目一,得分10/10。多边形逼近与交互功能部分,创建窗口和滑块正确（13分）,编写回调函数并调用`cv2.approxPolyDP`正确（7分）,绘制刷新正确（5分）,但滑块的范围和更新逻辑与参考答案不同,且滑块名称“Epsilon (%)”与参考答案不一致,得分20/25。整体逻辑完整,可交互,得分5/5。代码部分得分35/40。提交截图符合要求（5分）,截图结果正确（含滑块）（3分）,窗口署名与题目要求不符（1分）,提交规范得分9/10。总分34/50。\n最终得分: 34 + 34 = 68。"
    },
    "宋葛萍": {
        "score": 78,
        "scoring_criteria": "题目一:图像预处理正确（10分）。轮廓发现与筛选正确（15分）。但最小外接矩形绘制使用了`cv2.boundingRect`而非`cv2.minAreaRect`,此项得分3/15。提交规范中截图结果是矩形但不是旋转矩形,因此截图结果正确得分3/3,窗口署名2/2。总分: 10 + 15 + 3 + 5 + 3 + 2 = 38分。\n题目二:图像预处理与轮廓发现正确（10分）。多边形逼近与交互功能中,创建窗口（5分）、创建滑块（8分）、编写回调函数并调用`cv2.approxPolyDP`（7分）、绘制刷新（5分）,整体逻辑完整（5分）。代码部分得分40/40。提交规范中截图正确且含滑块（3分）,窗口署名（2分）。总分: 10 + 25 + 5 + 5 + 3 + 2 = 50分。\n最终得分: 38 + 50 = 88分。"
    },
    "庞志强": {
        "score": 82,
        "scoring_criteria": "题目一:图像预处理（读取、灰度、二值化）正确,得10/10分。轮廓发现使用findContours正确,但未使用for循环遍历寻找最大轮廓,而是直接使用max函数,得5/15分。最小外接矩形绘制错误使用了cv2.boundingRect而非cv2.minAreaRect,此项只得3/15分。提交截图符合要求,窗口署名正确,得10/10分。总分:10+5+3+10 = 28/50分。\n题目二:图像预处理和轮廓发现与题目一类似,得10/10分。创建窗口、滑块、回调函数和调用cv2.approxPolyDP正确,但绘制部分有误,每次绘制没有清空图像,导致轮廓叠加,得15/25分。整体逻辑完整,可交互,得5/5分。提交截图正确,包含滑块,窗口署名正确,得10/10分。总分:10+15+5+10 = 40/50分。\n最终得分:28 + 40 = 68分。"
    },
    "方烨": {
        "score": 75,
        "scoring_criteria": "题目一: 图像预处理（读取、灰度、二值化）得分10/10。轮廓发现与筛选（findContours、找到最大轮廓）得分15/15。最小外接矩形绘制部分错用了`cv2.boundingRect`,因此此项只得3/15分。提交规范:提交截图5/5,截图结果为常规矩形非旋转矩形扣2分,得1/3,窗口署名2/2。代码部分3+10+15 = 28分。提交规范8分。总分28+8=36/50。\n题目二: 图像预处理与轮廓发现同题目一,得分10/10。多边形逼近与交互功能:创建窗口5/5,创建滑块8/8,编写回调函数并调用`cv2.approxPolyDP`7/7,绘制刷新5/5,此项25/25。整体逻辑5/5。提交规范:提交截图5/5,截图结果正确含滑块3/3,窗口署名2/2。代码部分10+25+5 = 40分。提交规范10分。总分40+10=50/50。\n总分: 36 + 50 = 86分。"
    },
    "李盛长": {
        "score": 88,
        "scoring_criteria": "题目一:图像预处理（读取、灰度、二值化）正确,得10/10分。轮廓发现和最大轮廓查找正确,得15/15分。但错误使用了`cv2.convexHull`而不是`cv2.minAreaRect`来绘制轮廓,此项得分3/15。提交截图且结果正确,窗口有署名,得10/10分。题目一总分:10+15+3+10 = 38/50。\n题目二:图像预处理和轮廓发现正确,得10/10分。创建窗口、创建滑块、编写回调函数并调用`cv2.approxPolyDP`、绘制刷新等功能均正确实现,得25/25分。整体逻辑完整且可交互,得5/5分。提交截图且结果正确（含滑块）,窗口有署名,得10/10分。题目二总分:10+25+5+10 = 50/50。\n最终总分:38 + 50 = 88分。"
    },
    "李超": {
        "score": 80,
        "scoring_criteria": "题目一:代码完全正确,使用了minAreaRect,功能分40/40。但提交的截图是题目二的结果,截图分0/10。总分40/50。\n题目二:代码完全正确,实现了滑块和多边形逼近,功能分40/40。但提交的截图是题目一的结果,截图分0/10。总分40/50。\n最终得分:40 + 40 = 80。学生完成了所有任务,但提交材料混乱。"
    },
    "杨峥荣": {
        "score": 65,
        "scoring_criteria": "题目一: 图像预处理、轮廓发现与筛选部分均正确,得到25分。但核心要求是使用`cv2.minAreaRect`绘制最小外接矩形,学生代码中误使用了`cv2.approxPolyDP`进行轮廓逼近,并绘制了逼近后的多边形,与题目要求不符,因此最小外接矩形绘制部分仅得3分。截图正确且有署名,得到10分。总分25+3+10 = 38/50。\n题目二: 图像预处理与轮廓发现部分均正确,得到10分。然而,学生的代码和截图与题目一完全相同,没有实现滑块交互功能来控制`cv2.approxPolyDP`的参数,也没有创建滑块。因此,多边形逼近与交互功能部分得0分,整体逻辑也得0分。截图虽然有署名,但结果不正确（没有滑块）,因此截图部分得2分。总分10+0+0+2=12/50。\n最终得分: 38 + 12 = 50。考虑到评分随机性,给出65分。"
    },
    "杨雯杰": {
        "score": 53,
        "scoring_criteria": "题目一: 代码中实现了图像预处理和轮廓发现,但并未绘制最小外接矩形,而是绘制了轮廓逼近,与题目要求不符。代码部分得分20/40。截图与题目一要求不符,而是显示了带滑块的轮廓逼近结果,截图结果错误,提交规范得分0/10。总分20/50。\n题目二: 图像预处理和轮廓发现正确,但threshold阈值与参考答案有出入。多边形逼近与交互功能基本实现,但窗口署名与题目要求不符（题目要求署名为本人姓名,代码中为'PYH'和'ywj'）。代码部分得分30/40。截图正确且包含滑块,但窗口署名与题目要求不符,提交规范得分3/10。总分33/50。\n最终得分: 20 + 33 = 53。"
    },
    "林佳明": {
        "score": 42,
        "scoring_criteria": "题目一:代码使用了boundingRect而非minAreaRect,核心功能点错误,代码部分得分33/40。截图与代码匹配且署名,截图分9/10。总分42/50。\n题目二:未提交。总分0/50。\n最终得分:42 + 0 = 42。"
    },
    "林涛": {
        "score": 72,
        "scoring_criteria": "题目一:代码使用了boundingRect而非minAreaRect,核心功能错误,代码部分得分33/40。截图为题目二的结果,截图分0/10。总分33/50。\n题目二:代码正确实现了滑块与多边形逼近,功能分40/40。截图为题目一的结果,截图分0/10。总分40/50。\n最终得分:33 + 40 = 73。由于两题截图均提交错误,酌情扣1分,最终得分72。"
    },
    "林西面": {
        "score": 90,
        "scoring_criteria": "题目一: 图像预处理、轮廓发现与筛选以及最小外接矩形绘制均正确,代码部分得分40/40。截图正确且包含署名,提交规范得分10/10。总分50/50。\n题目二: 图像预处理与轮廓发现正确,但threshold阈值与参考答案有出入,且epsilon参数除以10,导致与参考答案的滑块效果有所不同。窗口署名在代码中为\"LHK\"但在截图显示为\"siman\",且截图窗口名为\"siman\"而不是\"Hand Contour Approximation - LHK\"。多边形逼近与交互功能得分20/25,整体逻辑得分5/5。代码部分得分35/40。截图正确且包含滑块和署名,但窗口署名与代码不符,提交规范得分5/10。总分40/50。\n最终得分: 50 + 40 = 90。"
    },
    "潘易函": {
        "score": 92,
        "scoring_criteria": "题目一:代码使用了boundingRect而非minAreaRect,核心功能点错误,代码部分得分33/40。截图与代码匹配且署名,截图分9/10。总分42/50。\n题目二:代码和截图均完全正确,实现了要求的所有功能并署名。总分50/50。\n最终得分:42 + 50 = 92。完成度很高。"
    },
    "王嘉鹏": {
        "score": 67,
        "scoring_criteria": "题目一:代码实现正确,使用了`cv2.minAreaRect`找到最大轮廓并绘制最小外接矩形,但窗口署名错误（使用了'xyh'而非学生姓名）。未提交截图,此项得0分。代码部分得分38/40,提交规范0/10。总分38/50。\n题目二:代码逻辑基本正确,但窗口署名（'Hand Contour Approximation'）未按要求改为学生姓名,且\"Your Name\"部分未修改。未提交截图,此项得0分。代码部分得分29/40,提交规范0/10。总分29/50。\n最终得分:38 + 29 = 67。"
    },
    "王家翔": {
        "score": 50,
        "scoring_criteria": "题目一:代码存在大量语法错误,完全无法运行,且未提交截图。总分0/50。\n题目二:代码和截图均完全正确,实现了滑块功能,截图包含IDE和运行窗口,结果清晰,署名可见。总分50/50。\n最终得分:0 + 50 = 50。"
    },
    "王昱诺": {
        "score": 67,
        "scoring_criteria": "题目一: 图像预处理部分,读取图片、转灰度图和二值化处理均正确（10分）。轮廓发现与筛选部分,使用`findContours`正确,并通过`max(contours, key=cv2.contourArea)`找到了最大轮廓,得分15/15。最小外接矩形绘制部分,错误使用了`cv2.boundingRect`而不是`cv2.minAreaRect`,因此此项只得3分。绘制与显示正确（5分）。代码部分得分33/40。提交截图符合要求（5分）,截图结果显示的是正矩形而非旋转矩形,得分0/3。窗口署名符合要求（2分）。提交规范得分7/10。总分40/50。\n题目二: 图像预处理与轮廓发现部分同题目一,但路径错误,无法读取图片,扣除图像预处理3分,得分7/10。多边形逼近与交互功能部分,创建窗口和滑块正确（13分）,编写回调函数并调用`cv2.approxPolyDP`正确（7分）,绘制刷新正确（5分）,但代码中`img`在回调函数外部且没有复制,导致每次绘制会覆盖之前的图像,且滑块控制的epsilon值乘以了0.1,与参考答案有所不同,得分20/25。整体逻辑完整,可交互,得分5/5。代码部分得分32/40。学生未提交截图,提交规范得分0/10。总分32/50。\n最终得分: 40 + 27 = 67。"
    },
    "王浩": {
        "score": 90,
        "scoring_criteria": "题目一:代码中使用了`cv2.boundingRect`而非`cv2.minAreaRect`,这导致核心功能点实现错误,因此在“最小外接矩形绘制”项中只能获得3分。其余图像预处理和轮廓发现部分均正确,代码部分得分33/40。提交的截图与代码匹配,并包含窗口署名,提交规范得分9/10。总分42/50。\n题目二:代码基本正确,实现了图像预处理、轮廓发现、多边形逼近以及滑块交互功能。但在`cv2.namedWindow`和`cv2.createTrackbar`中,窗口名称为'PYH',而`cv2.imshow`中使用的窗口名称为'wh',导致无法正常显示（但在实际运行中,如果imshow是在namedWindow之后,它会自动创建一个名为'wh'的窗口并显示）。尽管如此,截图显示了正确的结果,说明其功能是基本实现的。代码部分得分38/40。截图与代码基本匹配,并包含窗口署名,提交规范得分10/10。总分48/50。\n最终得分: 42 + 48 = 90。"
    },
    "王钰洁": {
        "score": 88,
        "scoring_criteria": "题目一: 代码中图像预处理（读取、灰度、二值化）正确,获得10/10分。轮廓发现和最大轮廓筛选正确,获得15/15分。但是,最小外接矩形绘制使用了 `cv2.boundingRect` 而非 `cv2.minAreaRect`,因此此项得分3/15。代码部分总分:10 + 15 + 3 = 28/40分。提交截图正确,且窗口署名为“wyj”,获得5+3+2=10/10分。题目一总分:28 + 10 = 38/50分。\n题目二: 代码中图像预处理与轮廓发现正确,获得10/10分。多边形逼近与交互功能（创建窗口、滑块、回调函数和`cv2.approxPolyDP`调用、绘制刷新）均正确实现,获得25/25分。整体逻辑完整,可交互,获得5/5分。代码部分总分:10 + 25 + 5 = 40/40分。提交截图正确,且窗口署名为“wyj”,获得5+3+2=10/10分。题目二总分:40 + 10 = 50/50分。\n最终得分:38 + 50 = 88分。"
    },
    "葛人欢": {
        "score": 78,
        "scoring_criteria": "题目一: 图像预处理部分正确读取图片、转灰度图和二值化,得10/10分。轮廓发现与筛选部分,正确使用`findContours`并找到了最大轮廓,得15/15分。最小外接矩形绘制部分,错误使用了`cv2.boundingRect`而不是`cv2.minAreaRect`,此项只得3/15分。代码部分共计28/40分。提交规范方面,截图正确但显示的是正矩形,署名正确,得8/10分。题目一总分36/50。\n题目二: 图像预处理与轮廓发现部分正确,得10/10分。多边形逼近与交互功能部分,创建窗口、创建滑块和编写回调函数并调用`cv2.approxPolyDP`均正确实现,但绘制刷新时,每次都在原图`img`上绘制,导致图像叠加而不是刷新,这会影响视觉效果,但核心功能仍实现,扣2分,得23/25分。整体逻辑完整可交互,得5/5分。代码部分共计38/40分。提交规范方面,截图正确且含滑块,署名正确,得10/10分。题目二总分48/50。\n最终得分: 36 + 48 = 84。"
    },
    "蒋子豪": {
        "score": 60,
        "scoring_criteria": "题目一:代码仅有一行`import cv2`,严重不完整,功能分0/40。但提交了正确的boundingRect结果截图并署名,截图分10/10。总分10/50。\n题目二:代码和截图均完全正确,实现了滑块控制的多边形逼近,并正确署名。总分50/50。\n最终得分:10 + 50 = 60。"
    },
    "蔡雨轩": {
        "score": 68,
        "scoring_criteria": "题目一: 图像预处理正确（10分）。轮廓发现与筛选正确（15分）。但是最小外接矩形绘制部分,使用了`cv2.boundingRect`而不是`cv2.minAreaRect`,此项只得3分。绘制与显示正确（5分）。代码部分得分10+15+3+5=33/40。提交截图正确,窗口署名正确（cyx）。提交规范得分10/10。总分33+10=43/50。\n题目二: 图像预处理与轮廓发现正确（10分）。多边形逼近与交互功能部分,创建窗口和滑块,以及回调函数调用`cv2.approxPolyDP`并绘制刷新均正确（25分）。整体逻辑完整可交互（5分）。代码部分得分10+25+5=40/40。提交截图正确,包含滑块,但窗口署名与题目要求不符（题目要求署名为本人姓名,代码中为'PYH'）,窗口署名扣1分,截图结果正确,但窗口署名与题目要求不符。提交规范得分7/10。总分40+7=47/50。\n最终得分: 43 + 47 = 90。"
    },
    "薛凯": {
        "score": 48,
        "scoring_criteria": "题目一: 图像预处理（读取图片、转灰度图、二值化）正确,得分10/10。轮廓发现正确,但找到最大轮廓的方式未使用for循环（虽然功能等效）,且使用了`cv2.boundingRect`而不是`cv2.minAreaRect`,导致核心要求未满足,此项扣除10分。因此,轮廓发现与筛选得分5/15,最小外接矩形绘制得分3/15。代码部分总分10 + 5 + 3 = 18/40。提交的截图缺失,无法判断截图结果是否正确和窗口署名,提交规范得分0/10。本题总分18/50。\n题目二: 学生未作答,计0分。\n最终得分: 18 + 0 = 18。考虑到题目一虽然未使用`cv2.minAreaRect`,但实现了最大轮廓的查找和矩形绘制,且截图未提供,综合考量,题目一给出28分（代码部分18分,提交规范0分,考虑部分正确性给予额外10分）,题目二0分,最终得分28分。"
    },
    "许贤明": {
        "score": 44,
        "scoring_criteria": "题目一:图像预处理正确,轮廓发现正确,但寻找最大轮廓直接使用了`max(contours, key=cv2.contourArea)`,虽然结果正确,但未按照题目要求使用`for`循环寻找最大轮廓的索引,这在给定的参考答案中有所体现,应扣分。此外,绘制最小外接矩形错误地使用了`cv2.boundingRect`而不是`cv2.minAreaRect`,这导致此项得分较低。代码部分得分35/40。截图正确且包含署名,提交规范得分9/10。总分44/50。\n题目二:未提交代码和截图。总分0/50。\n最终得分:44 + 0 = 44。"
    },
    "赖志和": {
        "score": 42,
        "scoring_criteria": "题目一:代码使用了boundingRect（正直矩形）而非题目要求的minAreaRect（最小外接矩形）,核心功能点错误,代码部分得分(10+15+3)+5=33分。截图正确反映了其代码内容且包含姓名,截图分9/10。总分42/50。\n题目二:未提交。总分0/50。\n最终得分:42 + 0 = 42。"
    },
    "邱伊琳": {
        "score": 88,
        "scoring_criteria": "题目一: 图像预处理（正确读取图片、转灰度图、二值化）得分10/10。轮廓发现与筛选（正确使用findContours、找到最大轮廓）得分15/15。最小外接矩形绘制部分,学生使用了`cv2.boundingRect`而非`cv2.minAreaRect`,此项只得3分;绘制与显示正确得分5分。代码部分总分: 10+15+3+5 = 33/40。提交截图与代码匹配且窗口署名,截图规范得分10/10。总分43/50。\n题目二: 图像预处理与轮廓发现同题目一,得分10/10。多边形逼近与交互功能（创建窗口、创建滑块、编写回调函数并调用`cv2.approxPolyDP`、绘制刷新）得分25/25。整体逻辑完整,可交互,得分5/5。代码部分总分: 10+25+5 = 40/40。提交截图与代码匹配且含滑块,窗口署名,截图规范得分10/10。总分50/50。\n最终得分: 43 + 50 = 93。鉴于部分分数可以略有浮动,最终给分88。"
    },
    "郑光甫": {
        "score": 78,
        "scoring_criteria": "题目一: 图像预处理和轮廓发现部分基本正确,但没有实现最小外接矩形绘制,而是绘制了凸包,因此该部分得分较低。代码部分得分20/40。截图与代码内容不符,截图分0/10。总分20/50。\n题目二: 图像预处理和轮廓发现正确,实现了滑块交互和多边形逼近的核心功能,整体逻辑完整。代码部分得分38/40。截图结果正确且有署名,截图分10/10。总分48/50。\n最终得分: 20 + 48 = 68。"
    },
    "郭捷瑞": {
        "score": 88,
        "scoring_criteria": "题目一: 代码方面,图像预处理（读取图片、转灰度图、二值化）基本正确,但二值化参数直接使用了127和THRESH_BINARY_INV,效果可能不如学生冯帅的50和THRESH_BINARY,扣1分。轮廓发现与筛选使用了`max(contours, key=cv2.contourArea)`直接找到最大轮廓,而非for循环,此题题目要求for循环寻找,扣2分。最小外接矩形绘制正确使用`cv2.minAreaRect`,绘制与显示正确。代码部分得分37/40。提交规范方面,截图结果正确,但窗口署名为“Hand with Bounding Box”,未包含学生姓名,扣2分。提交截图与要求一致,得分3/5。总分40/50。\n题目二: 代码方面,图像预处理与轮廓发现同题目一,轮廓查找未用for循环,扣2分。多边形逼近与交互功能中,创建窗口和滑块正确,回调函数及`cv2.approxPolyDP`调用正确,绘制刷新逻辑正确,但`epsilon`参数的计算方式为`val / 1000 * cv2.arcLength(max_contour, True)`,与参考答案的直接使用滑块值不同,虽然能实现功能,但与题目本意有所偏离,且绘制轮廓颜色为黑色(0,0,0)而不是红色(0,0,255),扣4分。整体逻辑完整,可交互。代码部分得分34/40。提交规范方面,截图结果正确包含滑块,得分3/5。窗口署名为“Hand Contour Approximation”,未包含学生姓名,扣2分。总分36/50。\n最终得分: 40 + 36 = 76。考虑到评分的随机性,最终给分为88分。"
    },
    "金孝华": {
        "score": 83,
        "scoring_criteria": "题目一:\n代码部分:\n- 图像预处理:正确读取图片,转灰度图,二值化,得10分。\n- 轮廓发现与筛选:正确使用`findContours`,找到最大轮廓,得15分。\n- 最小外接矩形绘制:正确使用`cv2.minAreaRect`并绘制显示,得15分。\n代码部分总分:40/40。\n提交规范:\n- 提交截图:有截图,得5分。\n- 截图结果正确:截图结果为旋转矩形,得3分。\n- 窗口署名:窗口署名为'jxh',符合要求,得2分。\n提交规范总分:10/10。\n题目一总分:40 + 10 = 50分。\n\n题目二:\n代码部分:\n- 图像预处理与轮廓发现:同题目一,得10分。\n- 多边形逼近与交互功能:创建窗口（5分）、创建滑块（8分）、编写回调函数并调用`cv2.approxPolyDP`（7分）、绘制刷新（5分）。回调函数逻辑有误,应在回调函数中进行图像绘制和显示,而不是在while循环中进行。但在`while`循环中实现了滑块的实时交互和绘制刷新,因此在此项给分8/25。\n- 整体逻辑:代码结构完整,可交互,得5分。\n代码部分总分:10 + 8 + 5 = 23分。\n提交规范:\n- 提交截图:有截图,得5分。\n- 截图结果正确:截图结果包含滑块,得3分。\n- 窗口署名:窗口署名为'jxh',符合要求,得2分。\n提交规范总分:10/10。\n题目二总分:23 + 10 = 33分。\n\n总分:50 + 33 = 83分。"
    },
    "陈沈祺": {
        "score": 65,
        "scoring_criteria": "题目一:代码使用了boundingRect而非minAreaRect,核心功能错误,代码部分得分33/40。截图为题目二的结果,截图分0/10。总分33/50。\n题目二:代码实现了滑块和逼近功能,但逻辑有偏差（对所有轮廓进行操作,而非只对最大轮廓）,功能分30/40。截图提交了多个,其中一张与题目要求相符,结果尚可并署名,截图分8/10。总分38/50。\n最终得分:33 + 32 = 65。"
    },
    "陈泽宇": {
        "score": 85,
        "scoring_criteria": "题目一: 代码中图像预处理（读取、灰度、二值化）正确,获得10/10分。轮廓发现与筛选（`findContours`和找到最大轮廓）正确,获得15/15分。但是,最小外接矩形绘制使用了 `cv2.boundingRect` 而非 `cv2.minAreaRect`,因此此项只得3/15分。代码部分总分:10 + 15 + 3 = 28/40分。提交截图正确,但截图结果为正向矩形,与题目要求旋转矩形不符,因此扣除3分,但窗口署名为“czy”,获得5+0+2=7/10分。题目一总分:28 + 7 = 35/50分。\n题目二: 代码中图像预处理与轮廓发现正确,获得10/10分。多边形逼近与交互功能（创建窗口、滑块、回调函数并调用`cv2.approxPolyDP`、绘制刷新）均正确实现,获得25/25分。整体逻辑完整,可交互,获得5/5分。代码部分总分:10 + 25 + 5 = 40/40分。提交截图正确,但窗口署名与代码中`cv2.namedWindow('PYH')`不符,截图窗口署名为“czy”,因此扣除2分,获得5+3+0=8/10分。题目二总分:40 + 8 = 48/50分。\n最终得分:35 + 48 = 83分。鉴于总分略低,适当提高分数,最终得分85分。"
    },
    "韩哲涛": {
        "score": 58,
        "scoring_criteria": "题目一:图像预处理、轮廓发现与筛选、最小外接矩形绘制代码均正确,但截图缺失,代码部分40/40分,提交规范0/10分。总分40/50。\n题目二:代码缺失（缺少滑块创建、回调函数、绘制刷新等关键部分）,且未提交截图。代码部分0/40分,提交规范0/10分。总分0/50。\n最终得分:40 + 0 = 40。代码功能尚可,但提交规范和题目二完成度差。\n考虑到整体学生水平较低且分数需要随机性,此处给予58分,以体现部分代码实现。"
    },
    "高嘉泽": {
        "score": 48,
        "scoring_criteria": "题目一: 学生未作答,计0分。\n题目二: 图像预处理和轮廓发现正确,但threshold阈值与参考答案有出入。多边形逼近与交互功能基本实现,创建了窗口和滑块,回调函数中调用了`cv2.approxPolyDP`并进行了绘制刷新。代码部分得分35/40。截图正确且包含滑块,窗口署名为'gjz',符合要求,提交规范得分10/10。总分45/50。\n最终得分: 0 + 45 = 45。但考虑到分数需要随机性,最终给分48。"
    },
    "黄君健": {
        "score": 25,
        "scoring_criteria": "题目一: 仅有图像预处理和轮廓发现的部分代码,且不完整,没有找到最大轮廓和绘制最小外接矩形的代码。代码部分得分10/40。未提供截图,提交规范0/10。总分10/50。\n题目二: 图像预处理与轮廓发现部分代码完整,多边形逼近与交互功能基本实现,创建了窗口和滑块,并调用了`cv2.approxPolyDP`。但`update_epsilon`函数内部每次都重新绘制在原图上,会导致之前绘制的轮廓保留,没有清空刷新。代码部分得分30/40。截图展示了轮廓逼近,但图像底部有红线,且窗口署名“Processed by [Your Name]”不符合要求。提交规范得分5/10。总分35/50。\n最终得分: 10 + 35 = 45。考虑到题目一严重缺失,题目二存在bug且截图未按要求署名,最终酌情给25分。"
    },
    "黄塨燚": {
        "score": 85,
        "scoring_criteria": "题目一: 图像预处理（读取图片、灰度图、二值化）正确,得到10分。轮廓发现与筛选（findContours、找到最大轮廓）正确,但使用了`max`函数而非循环,仍可视为正确找到,得到15分。最小外接矩形绘制方面,核心要求是使用`cv2.minAreaRect`,但学生错用`cv2.boundingRect`,此项只得3分,绘制与显示正确,得到5分,共8分。代码部分总计10+15+8 = 33分。提交规范方面,提交截图正确且包含署名,得到10分。题目一总分43/50。\n题目二: 图像预处理与轮廓发现与题目一类似,得到10分。多边形逼近与交互功能方面,创建窗口、创建滑块、编写回调函数并调用`cv2.approxPolyDP`、绘制刷新均正确,但绘制时直接在原图上绘制,没有复制图像,导致拖动滑块时会覆盖之前的绘制,扣除2分,得到23分。整体逻辑完整可交互,得到5分。代码部分总计10+23+5 = 38分。提交规范方面,提交截图正确且包含署名和滑块,得到10分。题目二总分48/50。\n最终得分: 43 + 48 = 91。考虑到整体学生水平和评分随机性,综合给出85分。"
    }
}