{
    "学生回答": {
        "倪旭玮": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/54c21359119d156a82512704f1a43b62.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n#读取模板图像\ntemplate = cv2.imread(\"img/yinhua.png\")\nplt.imshow(template )#显示模板图像\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\n#获取模板的大小（宽度与高度）\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\n# 画出检测到的部分\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"nxw\", imgcpy)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/f4b6d53d108022e13f38386136b4cf4b.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]#获取模板的宽度与高度\n#模板匹配过程（采用归一化平方差匹配法，匹配值越接近0，与图像的匹配度越好）\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.01#设置阈值\nloc = np.where(res<=threshold)  #获取匹配位置集合\nfor pt in zip(*loc[::-1]):     #循环标记匹配位置\n    cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 1)\ncv2.imshow(\"nxw\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\ntemplate = cv2.imread(\"img/qrcode_rot.png\")\nimg = cv2.imread(\"img/template.png\")\ndef find_corners(img, template):\n    # 使用模板匹配,返回匹配度矩阵\n    match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n    # 创建一个列表存储找到的三个角点坐标\n    corner_points = []\n    # 循环找到最大的三个匹配位置\n    for i in range(3):\n        _, _, _, max_loc = cv2.minMaxLoc(match_result)\n        # 将找到的点加入列表\n        x, y = max_loc\n        corner_points.append((x, y))\n        # 将已找到的位置清零,避免重复查找\n        match_result[y-5:y+5, x-5:x+5] = 0\n    return corner_points\ncorners = find_corners(img, template)\ndef get_rotation(corners):\n    # 提取所有x和y坐标值\n    x_values = [p[0] for p in corners]\n    y_values = [p[1] for p in corners]\n    # 排序\n    x_sorted = sorted(x_values)\n    y_sorted = sorted(y_values)\n    # 获取中间值\n    mid_x = x_sorted[1]\n    mid_y = y_sorted[1]\n    # 判断中间值离最小值近还是离最大值近\n    x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n    y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n    # 根据中间值位置判断旋转角度\n    if x_close_to_min and y_close_to_min:\n        return 0  # 中间x离最小值近，中间y离最小值近\n    elif x_close_to_min and not y_close_to_min:\n        return 270  # 中间x离最小值近，中间y离最大值近\n    elif not x_close_to_min and y_close_to_min:\n        return 90  # 中间x离最大值近，中间y离最小值近\n    else:\n        return 180  # 中间x离最大值近，中间y离最大值\ndef rotate_back(img, detected_angle):\n    if detected_angle == 90:\n        return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n    elif detected_angle == 180:\n        return cv2.rotate(img, cv2.ROTATE_180)\n    elif detected_angle == 270:\n        return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n    else:\n        return img\ncv2.imshow(\"nxw\",template)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            }
        },
        "倪理浩": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/32063ffdfd49dd64eca60f48f79cb748.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\n\nyinhua = cv2.imread('img/yinhua.png')\nblur = cv2.imread('img/yinhua_blur.jpg')\n\nres = cv2.matchTemplate(blur, yinhua, cv2.TM_CCOEFF_NORMED)\n_, _, _, max_loc = cv2.minMaxLoc(res)\n\nh, w = yinhua.shape[:2]\ncv2.rectangle(blur, max_loc, (max_loc[0]+w, max_loc[1]+h), (0,255,0), 2)\ncv2.imwrite('result.jpg', blur)"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/be2dc18f889a68a46508326553a05ab3.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\n\nt = cv2.imread('img/puke_t.png', 0)\nimg = cv2.imread('img/puke.png', 0)\n\nres = cv2.matchTemplate(img, t, cv2.TM_CCOEFF_NORMED)\nthresh = 0.8\nloc = np.where(res >= thresh)\n\nresult = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)\nfor pt in zip(*loc[::-1]):\n    cv2.rectangle(result, pt, (pt[0]+t.shape[1], pt[1]+t.shape[0]), (0,255,0), 2)\n\ncv2.imshow('NLH', result)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\nimport numpy as np\n\nqrcode = cv2.imread('img/qrcode_rot.png', cv2.IMREAD_GRAYSCALE)\ntemplate = cv2.imread('img/template.png', cv2.IMREAD_GRAYSCALE)\n\nqr_detector = cv2.QRCodeDetector()\n_, points, _ = qr_detector.detectAndDecode(qrcode)\n\nif points is not None:\n    points = np.squeeze(points) \n\n    dist1 = np.linalg.norm(points[0] - points[1])\n    dist2 = np.linalg.norm(points[0] - points[2])\n    dist3 = np.linalg.norm(points[1] - points[2])\n\n    max_dist = max(dist1, dist2, dist3)\n\n    if max_dist == dist1:\n        top_left = points[np.argmin([points[0][1], points[1][1]])]  # y坐标较小的为左上\n        bottom_right = points[2]\n    elif max_dist == dist2:\n        top_left = points[np.argmin([points[0][1], points[2][1]])]\n        bottom_right = points[1]\n    else:\n        top_left = points[np.argmin([points[1][1], points[2][1]])]\n        bottom_right = points[0]\n\n    remaining_point = [p for p in points if not np.array_equal(p, top_left) and not np.array_equal(p, bottom_right)][0]\n\n    if remaining_point[0] > top_left[0]:\n        top_right = remaining_point\n        bottom_left = bottom_right\n    else:\n        bottom_left = remaining_point\n        top_right = bottom_right\n\n\n    vector = top_right - top_left\n    angle = np.degrees(np.arctan2(vector[1], vector[0]))\n\n    print(f\"检测到的旋转角度: {angle}度\")\n\n    (h, w) = qrcode.shape[:2]\n    center = (w // 2, h // 2)\n    rotation_matrix = cv2.getRotationMatrix2D(center, angle, 1.0)\n    rotated = cv2.warpAffine(qrcode, rotation_matrix, (w, h), flags=cv2.INTER_CUBIC, borderMode=cv2.BORDER_REPLICATE)\n\n    cv2.imshow(\"NLH\", qrcode)\n    cv2.imshow(\"NLH\", rotated)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()\n\n    cv2.imwrite('img/qrcode_corrected.png', rotated)\nelse:\n    print(\"未检测到二维码\")"
                ]
            }
        },
        "冯帅": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/6c23c7915696a62b07709a9b1dd1abf7.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/img/yinhua.png\")\nimg = cv2.imread(\"img/img/yinhua_blur.jpg\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nres2 = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\nmin_val2, max_val2, min_loc2, max_loc2 = cv2.minMaxLoc(res2)\ntop_left2 = max_loc2\nbottom_right2 = (top_left2[0] + w, top_left2[1] + h)\nimgcpy2 = img.copy()\ncv2.rectangle(imgcpy2, top_left2, bottom_right2, (255,0, 0), 2)\ncv2.imshow(\"imgcpy2\", imgcpy2)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/9afb22dfe683d559ae47ae10feac38cf.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/img/puke_t.png\")\nimg = cv2.imread(\"img/img/puke.png\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.1\nloc = np.where(res<=threshold)\nfor pt in zip(*loc[::-1]):\n   cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"dst\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\ntemplate = cv2.imread(\"img/img/template.png\")\nimg_rot = cv2.imread(\"img/img/qrcode_rot.png\")\ndef find_corners(img, template):\n   match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n   corner_points = []\n   for i in range(3):\n       _, _, _, max_loc = cv2.minMaxLoc(match_result)\n       x, y = max_loc\n       corner_points.append((x, y))\n       match_result[y-5:y+5, x-5:x+5] = 0\n   return corner_points\ndef get_rotation(corners):\n   x_values = [p[0] for p in corners]\n   y_values = [p[1] for p in corners]\n   x_sorted = sorted(x_values)\n   y_sorted = sorted(y_values)\n   mid_x = x_sorted[1]\n   mid_y = y_sorted[1]\n   x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n   y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n   if x_close_to_min and y_close_to_min:\n       return 0 \n   elif x_close_to_min and not y_close_to_min:\n       return 270 \n   elif not x_close_to_min and y_close_to_min:\n       return 90 \n   else:\n       return 180 \ndef rotate_back(img, detected_angle):\n   if detected_angle == 90:\n       return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n   elif detected_angle == 180:\n       return cv2.rotate(img, cv2.ROTATE_180)\n   elif detected_angle == 270:\n       return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n   else:\n       return img\nif __name__==\"__main__\":\n   corners = find_corners(img_rot, template)\n   detected_angle=get_rotation(corners)\n   kidel=rotate_back(img_rot, detected_angle)\n   cv2.imshow(\"ddd\", kidel)\n   cv2.waitKey(0)\n   cv2.destroyAllWindows()"
                ]
            }
        },
        "华江辰": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/982b1df3236337f8519694c6ea59d836.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\ntemplate = cv2.imread(\"img/yinhua.png\")\nplt.imshow(template )\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 4)\ncv2.imshow(\"HJC\", imgcpy)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/0c0f5f55d4ff1b8b07d9695aa0cd7d05.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]\ncv2.namedWindow('HJC')\ndef on_trackbar(val):\n    threshold = val / 1000.0 \n    img_result = img.copy() \n    res = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\n    loc = np.where(res <= threshold)\n    for pt in zip(*loc[::-1]):\n        cv2.rectangle(img_result, pt, (pt[0] + w, pt[1] + h), (255, 0, 0), 1)\n    cv2.imshow('HJC', img_result)\ncv2.createTrackbar('Threshold', 'HJC', 30, 100, on_trackbar)\non_trackbar(30)  \nwhile True:\n    key = cv2.waitKey(1)\n    if key == 27: \n        break\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/9bb68484636674b64caf3a755749b5f8.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/template.png\")\nimg_rot = cv2.imread(\"img/qrcode_rot.png\")\ndef find_corners(img, template):\n    match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n    corner_points = []\n    for i in range(3):\n        _, _, _, max_loc = cv2.minMaxLoc(match_result)\n        x, y = max_loc\n        corner_points.append((x, y))\n        match_result[y-5:y+5, x-5:x+5] = 0\n    return corner_points\ncorners = find_corners(img_rot, template)\ndef get_rotation(corners):\n    x_values = [p[0] for p in corners]\n    y_values = [p[1] for p in corners]\n    x_sorted = sorted(x_values)\n    y_sorted = sorted(y_values)\n    mid_x = x_sorted[1]\n    mid_y = y_sorted[1]\n    x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n    y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n    if x_close_to_min and y_close_to_min:\n        return 0\n    elif x_close_to_min and not y_close_to_min:\n        return 270\n    elif not x_close_to_min and y_close_to_min:\n        return 90\n    else:\n        return 180\ndef rotate_back(img, detected_angle):\n    if detected_angle == 90:\n        return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n    elif detected_angle == 180:\n        return cv2.rotate(img, cv2.ROTATE_180)\n    elif detected_angle == 270:\n        return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n    else:\n        return img\ndetected_angle=get_rotation(corners)\nimg_rotate_back=rotate_back(img_rot,detected_angle)\ncv2.imshow(\"HJC\", img_rot)\ncv2.imshow(\"HJC1\", img_rotate_back)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            }
        },
        "叶挺": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/6c23c7915696a62b07709a9b1dd1abf7"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/img/yinhua.png\")\nimg = cv2.imread(\"img/img/yinhua_blur.jpg\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nres2 = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\nmin_val2, max_val2, min_loc2, max_loc2 = cv2.minMaxLoc(res2)\ntop_left2 = max_loc2\nbottom_right2 = (top_left2[0] + w, top_left2[1] + h)\nimgcpy2 = img.copy()\ncv2.rectangle(imgcpy2, top_left2, bottom_right2, (255,0, 0), 2)\ncv2.imshow(\"imgcpy2\", imgcpy2)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/9afb22dfe683d559ae47ae10feac38cf"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/img/puke_t.png\")\nimg = cv2.imread(\"img/img/puke.png\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.1\nloc = np.where(res<=threshold)\nfor pt in zip(*loc[::-1]):\n  cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"dst\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\ntemplate = cv2.imread(\"img/img/template.png\")\nimg_rot = cv2.imread(\"img/img/qrcode_rot.png\")\ndef find_corners(img, template):\n  match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n  corner_points = []\n  for i in range(3):\n      _, _, _, max_loc = cv2.minMaxLoc(match_result)\n      x, y = max_loc\n      corner_points.append((x, y))\n      match_result[y-5:y+5, x-5:x+5] = 0\n  return corner_points\ndef get_rotation(corners):\n  x_values = [p[0] for p in corners]\n  y_values = [p[1] for p in corners]\n  x_sorted = sorted(x_values)\n  y_sorted = sorted(y_values)\n  mid_x = x_sorted[1]\n  mid_y = y_sorted[1]\n  x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n  y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n  if x_close_to_min and y_close_to_min:\n      return 0\n  elif x_close_to_min and not y_close_to_min:\n      return 270\n  elif not x_close_to_min and y_close_to_min:\n      return 90\n  else:\n      return 180\ndef rotate_back(img, detected_angle):\n  if detected_angle == 90:\n      return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n  elif detected_angle == 180:\n      return cv2.rotate(img, cv2.ROTATE_180)\n  elif detected_angle == 270:\n      return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n  else:\n      return img\nif __name__==\"__main__\":\n  corners = find_corners(img_rot, template)\n  detected_angle=get_rotation(corners)\n  kidel=rotate_back(img_rot, detected_angle)\n  cv2.imshow(\"ddd\", kidel)\n  cv2.waitKey(0)\n  cv2.destroyAllWindows()"
                ]
            }
        },
        "叶桉鸣": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/7274792438cdc71a5d8ccb0362d0f501.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\ntemplate = cv2.imread(\"img/yinhua.png\")\nplt.imshow(template )#显示模板图像\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 4)\ncv2.imshow(\"yam\", imgcpy)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/3ced10beece6c116653ae3c07d23e76e.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]\ncv2.namedWindow('PuKe Detection')\ndef on_trackbar(val):\n    threshold = val / 1000.0\n    img_result = img.copy()\n    res = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\n    loc = np.where(res <= threshold)\n    for pt in zip(*loc[::-1]):\n        cv2.rectangle(img_result, pt, (pt[0] + w, pt[1] + h), (255, 0, 0), 2)\n    cv2.imshow('yam', img_result)\ncv2.createTrackbar('Threshold', 'yam', 30, 100, on_trackbar)\non_trackbar(30)\nwhile True:\n    key = cv2.waitKey(1)\n    if key == 27:\n        break\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/template.png\")\nimg_rot = cv2.imread(\"img/qrcode_rot.png\")\ndef find_corners(img, template):\n    match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n    corner_points = []\n    for i in range(3):\n        _, _, _, max_loc = cv2.minMaxLoc(match_result)\n        x, y = max_loc\n        corner_points.append((x, y))\n        match_result[y-5:y+5, x-5:x+5] = 0\n    return corner_points\ncorners = find_corners(img_rot, template)\ndef get_rotation(corners):\n    x_values = [p[0] for p in corners]\n    y_values = [p[1] for p in corners]\n    x_sorted = sorted(x_values)\n    y_sorted = sorted(y_values)\n    mid_x = x_sorted[1]\n    mid_y = y_sorted[1]\n    x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n    y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n    if x_close_to_min and y_close_to_min:\n        return 0\n    elif x_close_to_min and not y_close_to_min:\n        return 270\n    elif not x_close_to_min and y_close_to_min:\n        return 90\n    else:\n        return 180\ndef rotate_back(img, detected_angle):\n    if detected_angle == 90:\n        return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n    elif detected_angle == 180:\n        return cv2.rotate(img, cv2.ROTATE_180)\n    elif detected_angle == 270:\n        return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n    else:\n        return img\ndetected_angle = get_rotation(corners)\nimg_rotated_back = rotate_back(img_rot, detected_angle)\ncv2.imshow(\"yam\", img_rot)\ncv2.imshow(\"yam\", img_rotated_back)\ncv2.waitKey(0) \ncv2.destroyAllWindows()"
                ]
            }
        },
        "吕鸿凯": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/d9c61deb7120ed7281b46911c28545d5.png"
                ],
                "text": []
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/b0bdd8468c1404e3fe90899d351c49b0.png"
                ],
                "text": []
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\n\ntemplate = cv2.imread(\"img/template.png\")\nimg_rot = cv2.imread(\"img/qrcode_rot.png\")\ndef find_corners(img, template):\n# 使用模板匹配,返回匹配度矩阵\n    match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n    # 创建一个列表存储找到的三个角点坐标\n    corner_points = []\n    # 循环找到最大的三个匹配位置\n    for i in range(3):\n        _, _, _, max_loc = cv2.minMaxLoc(match_result)\n        # 将找到的点加入列表\n        x, y = max_loc\n        corner_points.append((x, y))\n        # 将已找到的位置清零,避免重复查找\n        match_result[y-5:y+5, x-5:x+5] = 0\n    return corner_points\ndef get_rotation(corners):\n# 提取所有x和y坐标值\n    x_values = [p[0] for p in corners]\n    y_values = [p[1] for p in corners]\n    # 排序\n    x_sorted = sorted(x_values)\n    y_sorted = sorted(y_values)\n    # 获取中间值\n    mid_x = x_sorted[1]\n    mid_y = y_sorted[1]\n    # 判断中间值离最小值近还是离最大值近\n    x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n    y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n    if x_close_to_min and y_close_to_min:\n        return 0 # 中间x离最小值近，中间y离最小值近\n    elif x_close_to_min and not y_close_to_min:\n        return 270 # 中间x离最小值近，中间y离最大值近\n    elif not x_close_to_min and y_close_to_min:\n        return 90 # 中间x离最大值近，中间y离最小值近\n    else:\n        return 180 # 中间x离最大值近，中间y离最大值近\ndef rotate_back(img, detected_angle):\n    if detected_angle == 90:\n        return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n    elif detected_angle == 180:\n        return cv2.rotate(img, cv2.ROTATE_180)\n    elif detected_angle == 270:\n        return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n    else:\n        return img\nif __name__==\"__main__\":\n    corners = find_corners(img_rot, template)\n    detected_angle=get_rotation(corners)\n    kidel=rotate_back(img_rot, detected_angle)\n    cv2.imshow(\"LHK\", kidel)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()"
                ]
            }
        },
        "吴世杰": {
            "题目1": {
                "images": [],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ntemplate = cv2.imread(\"img/yinhua.png\")\nplt.imshow(template )#显示模板图像\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\n#获取模板的大小（宽度与高度）\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\n# 画出检测到的部分\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"wh\", imgcpy)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n# 使用相关系数法（cv2.TM_CCOEFF_NORMED），匹配值越接近1越好\nres2 = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\nmin_val2, max_val2, min_loc2, max_loc2 = cv2.minMaxLoc(res2)\ntop_left2 = max_loc2 # 相关系数法用最大值\nbottom_right2 = (top_left2[0] + w, top_left2[1] + h)\nimgcpy2 = img.copy()\ncv2.rectangle(imgcpy2, top_left2, bottom_right2, (0, 255, 0), 2) # 用绿色框\ncv2.imshow(\"wh\", imgcpy2)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]#获取模板的宽度与高度\n#模板匹配过程（采用归一化平方差匹配法，匹配值越接近0，与图像的匹配度越好）\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.01#设置阈值\nloc = np.where(res<=threshold)  #获取匹配位置集合\nfor pt in zip(*loc[::-1]):     #循环标记匹配位置\n   cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"wh\",img)\n\n\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\ndef Callback(a):\n   threshold = cv2.getTrackbarPos(\"threshold\", windowName) # 获取滑动条的Type值\n   threshold = threshold/100\n   loc = np.where(res <= threshold)\n   imgcpy = img.copy()\n   for pt in zip(*loc[::-1]):\n      cv2.rectangle(imgcpy, pt, (pt[0] + w, pt[1] + h), 255, 5)\n   cv2.imshow(\"wh\", imgcpy)\nwindowName = \"wh2\" # 窗体名\ncv2.namedWindow(windowName, cv2.WINDOW_AUTOSIZE)\ncv2.imshow(windowName, img)\ncv2.createTrackbar(\"threshold\", windowName, 0, 10, Callback)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\n\ndef find_corners(img, template):\n   # 使用模板匹配,返回匹配度矩阵\n   match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n   # 创建一个列表存储找到的三个角点坐标\n   corner_points = []\n   # 循环找到最大的三个匹配位置\n   for i in range(3):\n       _, _, _, max_loc = cv2.minMaxLoc(match_result)\n       # 将找到的点加入列表\n       x, y = max_loc\n       corner_points.append((x, y))\n       # 将已找到的位置清零,避免重复查找\n       match_result[y-5:y+5, x-5:x+5] = 0\n   return corner_points\n\n\ndef get_rotation(corners):\n   # 提取所有x和y坐标值\n   x_values = [p[0] for p in corners]\n   y_values = [p[1] for p in corners]\n   # 排序\n   x_sorted = sorted(x_values)\n   y_sorted = sorted(y_values)\n   # 获取中间值\n   mid_x = x_sorted[1]\n   mid_y = y_sorted[1]\n   # 判断中间值离最小值近还是离最大值近\n   x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n   y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n   # 根据中间值位置判断旋转角度\n   if x_close_to_min and y_close_to_min:\n       return 0  # 中间x离最小值近，中间y离最小值近\n   elif x_close_to_min and not y_close_to_min:\n       return 270  # 中间x离最小值近，中间y离最大值近\n   elif not x_close_to_min and y_close_to_min:\n       return 90  # 中间x离最大值近，中间y离最小值近\n   else:\n       return 180  # 中间x离最大值近，中间y离最大值近\ndef rotate_back(img, detected_angle):\n   if detected_angle == 90:\n       return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n   elif detected_angle == 180:\n       return cv2.rotate(img, cv2.ROTATE_180)\n   elif detected_angle == 270:\n       return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n   else:\n       return img\nimg_rot=cv2.imread('img/qrcode_rot.png')\ntemplate=cv2.imread('img/template.png')\ncorners = find_corners(img_rot, template)\nget_rotation=get_rotation(corners)\nimg=rotate_back(img_rot,get_rotation)\ncv2.imshow('wh',img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            }
        },
        "吴争航": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/0884b81a15faa09abb69e6ab46c5fe25"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n#读取模板图像\ntemplate = cv2.imread(\"img/yinhua.png\")\nplt.imshow(template )#显示模板图像\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\n#获取模板的大小（宽度与高度）\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\n# 画出检测到的部分\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"imgcpy\", imgcpy)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/c171b86331ea26f3aea68089d9178939"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]#获取模板的宽度与高度\n#模板匹配过程（采用归一化平方差匹配法，匹配值越接近0，与图像的匹配度越好）\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.02#设置阈值\nloc = np.where(res<=threshold)  #获取匹配位置集合\nfor pt in zip(*loc[::-1]):     #循环标记匹配位置\n   cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 1)\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\ndef Callback(a):\n   threshold = cv2.getTrackbarPos(\"threshold\", windowName) # 获取滑动条的Type值\n   threshold = threshold/100\n   loc = np.where(res <= threshold)\n   imgcpy = img.copy()\n   for pt in zip(*loc[::-1]):\n      cv2.rectangle(imgcpy, pt, (pt[0] + w, pt[1] + h), 255, 5)\n   cv2.imshow(\"PYH\", imgcpy)\nwindowName = \"PYH\" # 窗体名\ncv2.namedWindow(windowName, cv2.WINDOW_AUTOSIZE)\ncv2.imshow(windowName, img)\ncv2.createTrackbar(\"threshold\", windowName, 0, 10, Callback)\ncv2.imshow(\"dst\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\nimport numpy as np\ndef load_images(template_path, image_path):\n   template = cv2.imread(template_path, cv2.IMREAD_GRAYSCALE)\n   img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)\n   return template, img\ndef find_qr_corners(img, template):\n   match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n   _, max_val, _, max_loc = cv2.minMaxLoc(match_result)\n   threshold = max_val * 0.8\n   loc = np.where(match_result >= threshold)\n   corners = []\n   for pt in zip(*loc[::-1]):\n       if all(np.linalg.norm(np.array(pt) - np.array(c)) > 10 for c in corners):\n           corners.append(pt)\n           if len(corners) == 3:  # QR码通常需要3个定位点\n               break\n   return corners\ndef calculate_rotation_angle(corners):\n   if len(corners) < 3:\n       return 0\n   center = np.mean(corners, axis=0)\n   angles = []\n   for (x, y) in corners:\n       dx, dy = x - center[0], y - center[1]\n       angles.append(np.degrees(np.arctan2(dy, dx)))\n   avg_angle = np.mean(angles)\n   if avg_angle < -45:\n       return 270\n   elif avg_angle < 45:\n       return 0\n   elif avg_angle < 135:\n       return 90\n   else:\n       return 180\ndef correct_rotation(img, angle):\n   (h, w) = img.shape[:2]\n   center = (w // 2, h // 2)\n   if angle != 0:\n       M = cv2.getRotationMatrix2D(center, angle, 1.0)\n       return cv2.warpAffine(img, M, (w, h))\n   return img\ntemplate, img = load_images(\"img/img/template.png\", \"img/img/qrcode_rot.png\")\ncorners = find_qr_corners(img, template)\nangle = calculate_rotation_angle(corners)\ncorrected_img = correct_rotation(img, angle)\ncv2.imshow(\"img\",img)\ncv2.imshow(\"pyh\", corrected_img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            }
        },
        "周愉越": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/b40293dd0a4dd71767b9c87bcad511f4.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/yinhua.png\")\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.1\nloc = np.where(res<=threshold)\nfor pt in zip(*loc[::-1]):\n   cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (0,0,255), 2)\ncv2.imshow(\"dst\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/7e9efeaa77316b581d37e8e5dc1cada6.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.1\nloc = np.where(res<=threshold)\nfor pt in zip(*loc[::-1]):\n cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"dst\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\ntemplate = cv2.imread(\"img/template.png\")\nimg_rot = cv2.imread(\"img/qrcode_rot.png\")\ndef find_corners(img, template):\n  match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n  corner_points = []\n  for i in range(3):\n      _, _, _, max_loc = cv2.minMaxLoc(match_result)\n      x, y = max_loc\n      corner_points.append((x, y))\n      match_result[y-5:y+5, x-5:x+5] = 0\n  return corner_points\ndef get_rotation(corners):\n  x_values = [p[0] for p in corners]\n  y_values = [p[1] for p in corners]\n  x_sorted = sorted(x_values)\n  y_sorted = sorted(y_values)\n  mid_x = x_sorted[1]\n  mid_y = y_sorted[1]\n  x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n  y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n  if x_close_to_min and y_close_to_min:\n      return 0\n  elif x_close_to_min and not y_close_to_min:\n      return 270\n  elif not x_close_to_min and y_close_to_min:\n      return 90\n  else:\n      return 180\ndef rotate_back(img, detected_angle):\n  if detected_angle == 90:\n      return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n  elif detected_angle == 180:\n      return cv2.rotate(img, cv2.ROTATE_180)\n  elif detected_angle == 270:\n      return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n  else:\n      return img\nif __name__==\"__main__\":\n  corners = find_corners(img_rot, template)\n  detected_angle=get_rotation(corners)\n  kidel=rotate_back(img_rot, detected_angle)\n  cv2.imshow(\"ddd\", kidel)\n  cv2.waitKey(0)\n  cv2.destroyAllWindows()"
                ]
            }
        },
        "周泽鑫": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/a1fb09adb7d220dec80582127035b5e5.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n#读取模板图像\ntemplate = cv2.imread(\"yinhua.png\")\nplt.imshow(template )#显示模板图像\nimg = cv2.imread(\"yinhua_blur.jpg\")\n#获取模板的大小（宽度与高度）\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\n# 画出检测到的部分\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"zzx\", imgcpy)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/0de4ee98259bf09bc1c61c08344645d7.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"puke_t.png\")\nimg = cv2.imread(\"puke.png\")\nh, w = template.shape[:2]#获取模板的宽度与高度\n#模板匹配过程（采用归一化平方差匹配法，匹配值越接近0，与图像的匹配度越好）\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.01#设置阈值\nloc = np.where(res<=threshold)  #获取匹配位置集合\nfor pt in zip(*loc[::-1]):     #循环标记匹配位置\n   cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"zzx\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\ndef find_corners(img, template):\nmatch_result = cv2.matchTemplate('img/qrcode_rot.png',template, cv2.TM_CCOEFF_NORMED)\n# 创建一个列表存储找到的三个角点坐标\ncorner_points = []\n# 循环找到最大的三个匹配位置\nfor i in range(3):\n_, _, _, max_loc = cv2.minMaxLoc(match_result)\n# 将找到的点加入列表\nx, y = max_loc\ncorner_points.append((x, y))\n# 将已找到的位置清零,避免重复查找\nmatch_result[y-5:y+5, x-5:x+5] = 0\nreturn corner_points\ncorners = find_corners(img_rot, template)\ndef get_rotation(corners):\n# 提取所有x和y坐标值\nx_values = [p[0] for p in corners]\ny_values = [p[1] for p in corners]\n# 排序\nx_sorted = sorted(x_values)\ny_sorted = sorted(y_values)\n# 获取中间值\nmid_x = x_sorted[1]\nmid_y = y_sorted[1]\n# 判断中间值离最小值近还是离最大值近\nx_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\ny_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n# 根据中间值位置判断旋转角度\nif x_close_to_min and y_close_to_min:\nreturn 0 # 中间x离最小值近，中间y离最小值近\nelif x_close_to_min and not y_close_to_min:\nreturn 270 # 中间x离最小值近，中间y离最大值近\nelif not x_close_to_min and y_close_to_min:\nreturn 90 # 中间x离最大值近，中间y离最小值近\nelse:\nreturn 180 # 中间x离最大值近，中间y离最大值近\ndef rotate_back(img, detected_angle):\nif detected_angle == 90:\n   return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\nelif detected_angle == 180:\n   return cv2.rotate(img, cv2.ROTATE_180)\nelif detected_angle == 270:\n   return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\nelse:\n   return img"
                ]
            }
        },
        "夏宇浩": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/fa77bf8ef63560cba6d783426b637646.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"yinhua.png\")\nimg = cv2.imread(\"yinhua_blur.jpg\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nres2 = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\nmin_val2, max_val2, min_loc2, max_loc2 = cv2.minMaxLoc(res2)\ntop_left2 = max_loc2 \nbottom_right2 = (top_left2[0] + w, top_left2[1] + h)\nimgcpy2 = img.copy()\ncv2.rectangle(imgcpy2, top_left2, bottom_right2, (255, 0, 0), 2)\ncv2.imshow(\"imgcpy2\", imgcpy2)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/083bd79aa44a36f5254d901bb68c7104.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"puke_t.png\")\nimg = cv2.imread(\"puke.png\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.1#设置阈值\nloc = np.where(res<=threshold)\nfor pt in zip(*loc[::-1]):  \n    cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"xiayuhao\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": []
            }
        },
        "夏忆豪": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/215489acaee4eca3552ba3df5adbde7a.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/yinhua.png\")\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.1\nloc = np.where(res<=threshold)\nfor pt in zip(*loc[::-1]):\n    cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (0,0,255), 2)\ncv2.imshow(\"dst\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/f3b9f6c94af7845ce51bf6df6b889201.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.1\nloc = np.where(res<=threshold)\nfor pt in zip(*loc[::-1]):\n  cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"dst\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\ntemplate = cv2.imread(\"img/template.png\")\nimg_rot = cv2.imread(\"img/qrcode_rot.png\")\ndef find_corners(img, template):\n  match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n  corner_points = []\n  for i in range(3):\n      _, _, _, max_loc = cv2.minMaxLoc(match_result)\n      x, y = max_loc\n      corner_points.append((x, y))\n      match_result[y-5:y+5, x-5:x+5] = 0\n  return corner_points\ndef get_rotation(corners):\n  x_values = [p[0] for p in corners]\n  y_values = [p[1] for p in corners]\n  x_sorted = sorted(x_values)\n  y_sorted = sorted(y_values)\n  mid_x = x_sorted[1]\n  mid_y = y_sorted[1]\n  x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n  y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n  if x_close_to_min and y_close_to_min:\n      return 0\n  elif x_close_to_min and not y_close_to_min:\n      return 270\n  elif not x_close_to_min and y_close_to_min:\n      return 90\n  else:\n      return 180\ndef rotate_back(img, detected_angle):\n  if detected_angle == 90:\n      return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n  elif detected_angle == 180:\n      return cv2.rotate(img, cv2.ROTATE_180)\n  elif detected_angle == 270:\n      return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n  else:\n      return img\nif __name__==\"__main__\":\n  corners = find_corners(img_rot, template)\n  detected_angle=get_rotation(corners)\n  kidel=rotate_back(img_rot, detected_angle)\n  cv2.imshow(\"ddd\", kidel)\n  cv2.waitKey(0)\n  cv2.destroyAllWindows()"
                ]
            }
        },
        "夏有德": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/dd0cf9755ea68712a08dbe643e9d33cb.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n#读取模板图像\ntemplate = cv2.imread(\"img/yinhua.png\")\nplt.imshow(template )#显示模板图像\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\n#获取模板的大小（宽度与高度）\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\n# 画出检测到的部分\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"xyd\", imgcpy)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n# 使用相关系数法（cv2.TM_CCOEFF_NORMED），匹配值越接近1越好\nres2 = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\nmin_val2, max_val2, min_loc2, max_loc2 = cv2.minMaxLoc(res2)\ntop_left2 = max_loc2 # 相关系数法用最大值\nbottom_right2 = (top_left2[0] + w, top_left2[1] + h)\nimgcpy2 = img.copy()\ncv2.rectangle(imgcpy2, top_left2, bottom_right2, (0, 255, 0), 2) # 用绿色框\ncv2.imshow(\"xyd\", imgcpy2)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/633d2551f4b046ed8a2fd47579244e7a.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]#获取模板的宽度与高度\n#模板匹配过程（采用归一化平方差匹配法，匹配值越接近0，与图像的匹配度越好）\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.01#设置阈值\nloc = np.where(res<=threshold)  #获取匹配位置集合\nfor pt in zip(*loc[::-1]):     #循环标记匹配位置\n    cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"xyd\",img)\n\n\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\ndef Callback(a):\n    threshold = cv2.getTrackbarPos(\"threshold\", windowName) # 获取滑动条的Type值\n    threshold = threshold/100\n    loc = np.where(res <= threshold)\n    imgcpy = img.copy()\n    for pt in zip(*loc[::-1]):\n       cv2.rectangle(imgcpy, pt, (pt[0] + w, pt[1] + h), 255, 5)\n    cv2.imshow(\"xyd\", imgcpy)\nwindowName = \"xyd2\" # 窗体名\ncv2.namedWindow(windowName, cv2.WINDOW_AUTOSIZE)\ncv2.imshow(windowName, img)\ncv2.createTrackbar(\"threshold\", windowName, 0, 10, Callback)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/a9e985a9d24460fc093f8e76c4aaa602.png"
                ],
                "text": [
                    "import cv2\n\ndef find_corners(img, template):\n    # 使用模板匹配,返回匹配度矩阵\n    match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n    # 创建一个列表存储找到的三个角点坐标\n    corner_points = []\n    # 循环找到最大的三个匹配位置\n    for i in range(3):\n        _, _, _, max_loc = cv2.minMaxLoc(match_result)\n        # 将找到的点加入列表\n        x, y = max_loc\n        corner_points.append((x, y))\n        # 将已找到的位置清零,避免重复查找\n        match_result[y-5:y+5, x-5:x+5] = 0\n    return corner_points\n\n\ndef get_rotation(corners):\n    # 提取所有x和y坐标值\n    x_values = [p[0] for p in corners]\n    y_values = [p[1] for p in corners]\n    # 排序\n    x_sorted = sorted(x_values)\n    y_sorted = sorted(y_values)\n    # 获取中间值\n    mid_x = x_sorted[1]\n    mid_y = y_sorted[1]\n    # 判断中间值离最小值近还是离最大值近\n    x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n    y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n    # 根据中间值位置判断旋转角度\n    if x_close_to_min and y_close_to_min:\n        return 0  # 中间x离最小值近，中间y离最小值近\n    elif x_close_to_min and not y_close_to_min:\n        return 270  # 中间x离最小值近，中间y离最大值近\n    elif not x_close_to_min and y_close_to_min:\n        return 90  # 中间x离最大值近，中间y离最小值近\n    else:\n        return 180  # 中间x离最大值近，中间y离最大值近\ndef rotate_back(img, detected_angle):\n    if detected_angle == 90:\n        return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n    elif detected_angle == 180:\n        return cv2.rotate(img, cv2.ROTATE_180)\n    elif detected_angle == 270:\n        return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n    else:\n        return img\nimg_rot=cv2.imread('img/qrcode_rot.png')\ntemplate=cv2.imread('img/template.png')\ncorners = find_corners(img_rot, template)\nget_rotation=get_rotation(corners)\nimg=rotate_back(img_rot,get_rotation)\ncv2.imshow('wh',img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            }
        },
        "宋葛萍": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/a2c96f731aa7ef78758d64fa34dccdd0.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\ntemplate = cv2.imread(\"img/yinhua.png\")\nplt.imshow(template )\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"sgp\", imgcpy)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\nres2 = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\nmin_val2, max_val2, min_loc2, max_loc2 = cv2.minMaxLoc(res2)\ntop_left2 = max_loc2 \nbottom_right2 = (top_left2[0] + w, top_left2[1] + h)\nimgcpy2 = img.copy()\ncv2.rectangle(imgcpy2, top_left2, bottom_right2, (0, 255, 0), 2) \ncv2.imshow(\"imgcpy2\", imgcpy2)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/a7c10fe05c6380c51a80b5c96354b924.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.01\nloc = np.where(res<=threshold)  \nfor pt in zip(*loc[::-1]):    \n    cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"sgp\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\ndef Callback(a):\n    threshold = cv2.getTrackbarPos(\"threshold\", windowName) \n    threshold = threshold/100\n    loc = np.where(res <= threshold)\n    imgcpy = img.copy()\n    for pt in zip(*loc[::-1]):\n       cv2.rectangle(imgcpy, pt, (pt[0] + w, pt[1] + h), 255, 5)\n    cv2.imshow(\"JXJ\", imgcpy)\nwindowName = \"JXJ\"\ncv2.namedWindow(windowName, cv2.WINDOW_AUTOSIZE)\ncv2.imshow(windowName, img)\ncv2.createTrackbar(\"threshold\", windowName, 0, 10, Callback)"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\nimport numpy as np\ndef load_images(template_path, image_path):\ntemplate = cv2.imread(template_path, cv2.IMREAD_GRAYSCALE)\nimg = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)\nreturn template, img\ndef find_qr_corners(img, template):\nmatch_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n_, max_val, _, max_loc = cv2.minMaxLoc(match_result)\nthreshold = max_val * 0.8\nloc = np.where(match_result >= threshold)\ncorners = []\nfor pt in zip(*loc[::-1]):\nif all(np.linalg.norm(np.array(pt) - np.array(c)) > 10 for c in corners):\ncorners.append(pt)\nif len(corners) == 3:  # QR码通常需要3个定位点\nbreak\nreturn corners\ndef calculate_rotation_angle(corners):\nif len(corners) < 3:\nreturn 0\ncenter = np.mean(corners, axis=0)\nangles = []\nfor (x, y) in corners:\ndx, dy = x - center[0], y - center[1]\nangles.append(np.degrees(np.arctan2(dy, dx)))\navg_angle = np.mean(angles)\nif avg_angle < -45:\nreturn 270\nelif avg_angle < 45:\nreturn 0\nelif avg_angle < 135:\nreturn 90\nelse:\nreturn 180\ndef correct_rotation(img, angle):\n(h, w) = img.shape[:2]\ncenter = (w // 2, h // 2)\nif angle != 0:\nM = cv2.getRotationMatrix2D(center, angle, 1.0)\nreturn cv2.warpAffine(img, M, (w, h))\nreturn img\ntemplate, img = load_images(\"img/img/template.png\", \"img/img/qrcode_rot.png\")\ncorners = find_qr_corners(img, template)\nangle = calculate_rotation_angle(corners)\ncorrected_img = correct_rotation(img, angle)\ncv2.imshow(\"img\",img)\ncv2.imshow(\"sgp\", corrected_img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            }
        },
        "庞志强": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/68b57a539638ee5ba8a71532e23e65e6.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/yinhua.png\")\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\nh, w = template.shape[:2]#获取模板的宽度与高度\n#模板匹配过程（采用归一化平方差匹配法，匹配值越接近0，与图像的匹配度越好）\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.01#设置阈值\nloc = np.where(res<=threshold)  #获取匹配位置集合\nprint(loc)\nfor pt in zip(*loc[::-1]):     #循环标记匹配位置\n    cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\n    break\ncv2.imshow(\"pzq\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/389d09109aa52f5056989a37bd7c243f.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]#获取模板的宽度与高度\n#模板匹配过程（采用归一化平方差匹配法，匹配值越接近0，与图像的匹配度越好）\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.01#设置阈值\nloc = np.where(res<=threshold)  #获取匹配位置集合\nprint(loc)\nfor pt in zip(*loc[::-1]):     #循环标记匹配位置\n    cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"pzq\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/964a8f22ae81ceef89f4f0d5a818686b.png"
                ],
                "text": [
                    "import cv2\n\n\n\ndef find_corners(img, template):\n    # 使用模板匹配,返回匹配度矩阵\n    match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n    # 创建一个列表存储找到的三个角点坐标\n    corner_points = []\n    # 循环找到最大的三个匹配位置\n    for i in range(3):\n        _, _, _, max_loc = cv2.minMaxLoc(match_result)\n        # 将找到的点加入列表\n        x, y = max_loc\n        corner_points.append((x, y))\n        # 将已找到的位置清零,避免重复查找\n        match_result[y-5:y+5, x-5:x+5] = 0\n    return corner_points\n\n\n\n\ndef get_rotation(corners):\n    # 提取所有x和y坐标值\n    x_values = [p[0] for p in corners]\n    y_values = [p[1] for p in corners]\n    # 排序\n    x_sorted = sorted(x_values)\n    y_sorted = sorted(y_values)\n    # 获取中间值\n    mid_x = x_sorted[1]\n    mid_y = y_sorted[1]\n    # 判断中间值离最小值近还是离最大值近\n    x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n    y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n\n    # 根据中间值位置判断旋转角度\n    if x_close_to_min and y_close_to_min:\n        return 0  # 中间x离最小值近，中间y离最小值近\n    elif x_close_to_min and not y_close_to_min:\n        return 270  # 中间x离最小值近，中间y离最大值近\n    elif not x_close_to_min and y_close_to_min:\n        return 90  # 中间x离最大值近，中间y离最小值近\n    else:\n        return 180  # 中间x离最大值近，中间y离最大值近\n\ndef rotate_back(img, detected_angle):\n    if detected_angle == 90:\n        return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n    elif detected_angle == 180:\n        return cv2.rotate(img, cv2.ROTATE_180)\n    elif detected_angle == 270:\n        return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n    else:\n        return img\n\nimg_rot=cv2.imread('img/qrcode_rot.png')\ntemplate=cv2.imread('img/template.png')\ncorners = find_corners(img_rot, template)\nget_rotation=get_rotation(corners)\nimg=rotate_back(img_rot,get_rotation)\ncv2.imshow('pzq',img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            }
        },
        "方烨": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/927731f9806fae5c0bb75991703cdda7.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n#读取模板图像\ntemplate = cv2.imread(\"img/yinhua.png\")\nplt.imshow(template )#显示模板图像\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\n#获取模板的大小（宽度与高度）\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\n# 画出检测到的部分\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"fy\", imgcpy)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n# 使用相关系数法（cv2.TM_CCOEFF_NORMED），匹配值越接近1越好\nres2 = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\nmin_val2, max_val2, min_loc2, max_loc2 = cv2.minMaxLoc(res2)\ntop_left2 = max_loc2 # 相关系数法用最大值\nbottom_right2 = (top_left2[0] + w, top_left2[1] + h)\nimgcpy2 = img.copy()\ncv2.rectangle(imgcpy2, top_left2, bottom_right2, (0, 255, 0), 2) # 用绿色框\ncv2.imshow(\"imgcpy2\", imgcpy2)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/d9676b0b4219cc96408a1f3960a9245d.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]#获取模板的宽度与高度\n#模板匹配过程（采用归一化平方差匹配法，匹配值越接近0，与图像的匹配度越好）\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.01#设置阈值\nloc = np.where(res<=threshold)\n#获取匹配位置集合\nfor pt in zip(*loc[::-1]):\n\n#循环标记匹配位置\ncv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"fy\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\ndef Callback(a):\n\nthreshold = cv2.getTrackbarPos(\"threshold\", windowName) # 获取滑动条的Type值\n\nthreshold = threshold/100\n\nloc = np.where(res <= threshold)\n\nimgcpy = img.copy()\n\nfor pt in zip(*loc[::-1]):\n\n\ncv2.rectangle(imgcpy, pt, (pt[0] + w, pt[1] + h), 255, 5)\n\ncv2.imshow(\"JXJ\", imgcpy)\nwindowName = \"JXJ\" # 窗体名\ncv2.namedWindow(windowName, cv2.WINDOW_AUTOSIZE)\ncv2.imshow(windowName, img)\ncv2.createTrackbar(\"threshold\", windowName, 0, 10, Callback)"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\nimport numpy as np\ndef load_images(template_path, image_path):\n    template = cv2.imread(template_path, cv2.IMREAD_GRAYSCALE)\n    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)\n    return template, img\ndef find_qr_corners(img, template):\n    match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n    _, max_val, _, max_loc = cv2.minMaxLoc(match_result)\n    threshold = max_val * 0.8\n    loc = np.where(match_result >= threshold)\n    corners = []\n    for pt in zip(*loc[::-1]):\n        if all(np.linalg.norm(np.array(pt) - np.array(c)) > 10 for c in corners):\n            corners.append(pt)\n            if len(corners) == 3:  # QR码通常需要3个定位点\n                break\n    return corners\ndef calculate_rotation_angle(corners):\n    if len(corners) < 3:\n        return 0\n    center = np.mean(corners, axis=0)\n    angles = []\n    for (x, y) in corners:\n        dx, dy = x - center[0], y - center[1]\n        angles.append(np.degrees(np.arctan2(dy, dx)))\n    avg_angle = np.mean(angles)\n    if avg_angle < -45:\n        return 270\n    elif avg_angle < 45:\n        return 0\n    elif avg_angle < 135:\n        return 90\n    else:\n        return 180\ndef correct_rotation(img, angle):\n    (h, w) = img.shape[:2]\n    center = (w // 2, h // 2)\n    if angle != 0:\n        M = cv2.getRotationMatrix2D(center, angle, 1.0)\n        return cv2.warpAffine(img, M, (w, h))\n    return img\ntemplate, img = load_images(\"img/img/template.png\", \"img/img/qrcode_rot.png\")\ncorners = find_qr_corners(img, template)\nangle = calculate_rotation_angle(corners)\ncorrected_img = correct_rotation(img, angle)\ncv2.imshow(\"img\",img)\ncv2.imshow(\"fy\", corrected_img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            }
        },
        "李盛长": {
            "题目1": {
                "images": [],
                "text": [
                    "import numpy as np\nimport matplotlib.pyplot as plt\ntemplate = cv2.imread(\"img/yinhua.png\")\nplt.imshow(template )#显示模板图像\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\n#获取模板的大小（宽度与高度）\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\n# 画出检测到的部分\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"wh\", imgcpy)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n# 使用相关系数法（cv2.TM_CCOEFF_NORMED），匹配值越接近1越好\nres2 = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\nmin_val2, max_val2, min_loc2, max_loc2 = cv2.minMaxLoc(res2)\ntop_left2 = max_loc2 # 相关系数法用最大值\nbottom_right2 = (top_left2[0] + w, top_left2[1] + h)\nimgcpy2 = img.copy()\ncv2.rectangle(imgcpy2, top_left2, bottom_right2, (0, 255, 0), 2) # 用绿色框\ncv2.imshow(\"wh\", imgcpy2)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]#获取模板的宽度与高度\n#模板匹配过程（采用归一化平方差匹配法，匹配值越接近0，与图像的匹配度越好）\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.01#设置阈值\nloc = np.where(res<=threshold)  #获取匹配位置集合\nfor pt in zip(*loc[::-1]):     #循环标记匹配位置\ncv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"wh\",img)\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\ndef Callback(a):\nthreshold = cv2.getTrackbarPos(\"threshold\", windowName) # 获取滑动条的Type值\nthreshold = threshold/100\nloc = np.where(res <= threshold)\nimgcpy = img.copy()\nfor pt in zip(*loc[::-1]):\ncv2.rectangle(imgcpy, pt, (pt[0] + w, pt[1] + h), 255, 5)\ncv2.imshow(\"wh\", imgcpy)\nwindowName = \"wh2\" # 窗体名\ncv2.namedWindow(windowName, cv2.WINDOW_AUTOSIZE)\ncv2.imshow(windowName, img)\ncv2.createTrackbar(\"threshold\", windowName, 0, 10, Callback)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\ndef find_corners(img, template):\n# 使用模板匹配,返回匹配度矩阵\nmatch_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n# 创建一个列表存储找到的三个角点坐标\ncorner_points = []\n# 循环找到最大的三个匹配位置\nfor i in range(3):\n_, _, _, max_loc = cv2.minMaxLoc(match_result)\n# 将找到的点加入列表\nx, y = max_loc\ncorner_points.append((x, y))\n# 将已找到的位置清零,避免重复查找\nmatch_result[y-5:y+5, x-5:x+5] = 0\nreturn corner_points\ndef get_rotation(corners):\n# 提取所有x和y坐标值\nx_values = [p[0] for p in corners]\ny_values = [p[1] for p in corners]\n# 排序\nx_sorted = sorted(x_values)\ny_sorted = sorted(y_values)\n# 获取中间值\nmid_x = x_sorted[1]\nmid_y = y_sorted[1]\n# 判断中间值离最小值近还是离最大值近\nx_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\ny_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n# 根据中间值位置判断旋转角度\nif x_close_to_min and y_close_to_min:\nreturn 0  # 中间x离最小值近，中间y离最小值近\nelif x_close_to_min and not y_close_to_min:\nreturn 270  # 中间x离最小值近，中间y离最大值近\nelif not x_close_to_min and y_close_to_min:\nreturn 90  # 中间x离最大值近，中间y离最小值近\nelse:\nreturn 180  # 中间x离最大值近，中间y离最大值近\ndef rotate_back(img, detected_angle):\nif detected_angle == 90:\nreturn cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\nelif detected_angle == 180:\nreturn cv2.rotate(img, cv2.ROTATE_180)\nelif detected_angle == 270:\nreturn cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\nelse:\nreturn img\nimg_rot=cv2.imread('img/qrcode_rot.png')\ntemplate=cv2.imread('img/template.png')\ncorners = find_corners(img_rot, template)\nget_rotation=get_rotation(corners)\nimg=rotate_back(img_rot,get_rotation)\ncv2.imshow('wh',img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            }
        },
        "李超": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/bcfa199230539a1ee54661981780ecd9.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"yinhua.png\")\nimg = cv2.imread(\"yinhua_blur.jpg\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nres2 = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\nmin_val2, max_val2, min_loc2, max_loc2 = cv2.minMaxLoc(res2)\ntop_left2 = max_loc2\nbottom_right2 = (top_left2[0] + w, top_left2[1] + h)\nimgcpy2 = img.copy()\ncv2.rectangle(imgcpy2, top_left2, bottom_right2, (255,0, 0), 2) # 用绿色框\ncv2.imshow(\"imgcpy2\", imgcpy2)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/1bb6b3919e43ea77a596fafc5a5a145b.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"puke_t.png\")\nimg = cv2.imread(\"puke.png\")\nh, w = template.shape[:2]#获取模板的宽度与高度\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.1#设置阈值\nloc = np.where(res<=threshold)  #获取匹配位置集合\nfor pt in zip(*loc[::-1]):     #循环标记匹配位置\n   cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"dst\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"puke_t.png\")\nimg = cv2.imread(\"puke.png\")\nh, w = template.shape[:2]#获取模板的宽度与高度\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.1#设置阈值\nloc = np.where(res<=threshold)  #获取匹配位置集合\nfor pt in zip(*loc[::-1]):     #循环标记匹配位置\n   cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"dst\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            }
        },
        "杨峥荣": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/18120c323150b9751e7783368a95c585.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/yinhua.png\")\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\nh, w = template.shape[:2]#获取模板的宽度与高度\n#模板匹配过程（采用归一化平方差匹配法，匹配值越接近0，与图像的匹配度越好）\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.1#设置阈值\nloc = np.where(res<=threshold)  #获取匹配位置集合\nfor pt in zip(*loc[::-1]):     #循环标记匹配位置\n    cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (0,0,255), 2)\ncv2.imshow(\"dst\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/da261afe2a8960ae463614657f0519e0.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]#获取模板的宽度与高度\n#模板匹配过程（采用归一化平方差匹配法，匹配值越接近0，与图像的匹配度越好）\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.1#设置阈值\nloc = np.where(res<=threshold)  #获取匹配位置集合\nfor pt in zip(*loc[::-1]):     #循环标记匹配位置\n    cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (0,0,255), 2)\ncv2.imshow(\"dst\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": []
            }
        },
        "杨雯杰": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/999cbefeb26aacbaf00fd67d02e71ff3.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n#读取模板图像\ntemplate = cv2.imread(\"img/yinhua.png\")\nplt.imshow(template )#显示模板图像\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\n#获取模板的大小（宽度与高度）\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\n# 画出检测到的部分\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"ywj\", imgcpy)\n# 使用相关系数法（cv2.TM_CCOEFF_NORMED），匹配值越接近1越好\nres2 = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\nmin_val2, max_val2, min_loc2, max_loc2 = cv2.minMaxLoc(res2)\ntop_left2 = max_loc2 # 相关系数法用最大值\nbottom_right2 = (top_left2[0] + w, top_left2[1] + h)\nimgcpy2 = img.copy()\ncv2.rectangle(imgcpy2, top_left2, bottom_right2, (0, 255, 0), 2) # 用绿色框\ncv2.imshow(\"ywj1\", imgcpy2)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/7cebbbf05b1df6ccb416484639bf5b85.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]#获取模板的宽度与高度\n#模板匹配过程（采用归一化平方差匹配法，匹配值越接近0，与图像的匹配度越好）\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.1#设置阈值\nloc = np.where(res&lt;=threshold)  #获取匹配位置集合\nfor pt in zip(*loc[::-1]):     #循环标记匹配位置\ncv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"ywj\",img)\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\ndef Callback(a):\nthreshold = cv2.getTrackbarPos(\"threshold\", windowName) # 获取滑动条的Type值\nthreshold = threshold/100\nloc = np.where(res &lt;= threshold)\nimgcpy = img.copy()\nfor pt in zip(*loc[::-1]):\ncv2.rectangle(imgcpy, pt, (pt[0] + w, pt[1] + h), 255, 5)\ncv2.imshow(\"ywj\", imgcpy)\nwindowName = \"ywj\" # 窗体名\ncv2.namedWindow(windowName, cv2.WINDOW_AUTOSIZE)\ncv2.imshow(windowName, img)\ncv2.createTrackbar(\"threshold\", windowName, 0, 10, Callback)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\ndef find_corners(img, template):\n# 使用模板匹配,返回匹配度矩阵\nmatch_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n# 创建一个列表存储找到的三个角点坐标\ncorner_points = []\n# 循环找到最大的三个匹配位置\nfor i in range(3):\n_, _, _, max_loc = cv2.minMaxLoc(match_result)\n# 将找到的点加入列表\nx, y = max_loc\ncorner_points.append((x, y))\n# 将已找到的位置清零,避免重复查找\nmatch_result[y-5:y+5, x-5:x+5] = 0\nreturn corner_points\ndef get_rotation(corners):\n# 提取所有x和y坐标值\nx_values = [p[0] for p in corners]\ny_values = [p[1] for p in corners]\n# 排序\nx_sorted = sorted(x_values)\ny_sorted = sorted(y_values)\n# 获取中间值\nmid_x = x_sorted[1]\nmid_y = y_sorted[1]\n# 判断中间值离最小值近还是离最大值近\nx_close_to_min = (mid_x - x_sorted[0]) &lt; (x_sorted[2] - mid_x)\ny_close_to_min = (mid_y - y_sorted[0]) &lt; (y_sorted[2] - mid_y)\n# 根据中间值位置判断旋转角度\nif x_close_to_min and y_close_to_min:\nreturn 0  # 中间x离最小值近，中间y离最小值近\nelif x_close_to_min and not y_close_to_min:\nreturn 270  # 中间x离最小值近，中间y离最大值近\nelif not x_close_to_min and y_close_to_min:\nreturn 90  # 中间x离最大值近，中间y离最小值近\nelse:\nreturn 180  # 中间x离最大值近，中间y离最大值近\ndef rotate_back(img, detected_angle):\nif detected_angle == 90:\nreturn cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\nelif detected_angle == 180:\nreturn cv2.rotate(img, cv2.ROTATE_180)\nelif detected_angle == 270:\nreturn cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\nelse:\nreturn img\nimg_rot=cv2.imread('img/qrcode_rot.png')\ntemplate=cv2.imread('img/template.png')\ncorners = find_corners(img_rot, template)\nget_rotation=get_rotation(corners)\nimg=rotate_back(img_rot,get_rotation)\ncv2.imshow('ywj',img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            }
        },
        "林佳明": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/f558a342f17ead47efccd932c47eafd9.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\ntemplate = cv2.imread(\"img/yinhua.png\")\nplt.imshow(template )\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"imgcpy\", imgcpy)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/7d9dbfeb43596d5a0c6355b7a5b5c705.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\ndef Callback(a):\n    threshold = cv2.getTrackbarPos(\"threshold\", windowName)\n    threshold = threshold/100\n    loc = np.where(res <= threshold)\n    imgcpy = img.copy()\n    for pt in zip(*loc[::-1]):\n       cv2.rectangle(imgcpy, pt, (pt[0] + w, pt[1] + h), 255, 5)\n    cv2.imshow(\"ljm\", imgcpy)\nwindowName = \"ljm\"\ncv2.namedWindow(windowName, cv2.WINDOW_AUTOSIZE)\ncv2.imshow(windowName, img)\ncv2.createTrackbar(\"threshold\", windowName, 0, 10, Callback)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": []
            }
        },
        "林涛": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/2ef8806712b820f0338e937ff9f30071"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/yinhua.png\")\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nres2 = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\nmin_val2, max_val2, min_loc2, max_loc2 = cv2.minMaxLoc(res2)\ntop_left2 = max_loc2\nbottom_right2 = (top_left2[0] + w, top_left2[1] + h)\nimgcpy2 = img.copy()\ncv2.rectangle(imgcpy2, top_left2, bottom_right2, (255,0, 0), 2) # 用绿色框\ncv2.imshow(\"lintao\", imgcpy2)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/f8d814c95647faed7c4525a0b0d80032"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.1\nloc = np.where(res<=threshold)\nfor pt in zip(*loc[::-1]):\n  cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"lt\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/be5ff60126249ac9ee14f29e04d9ba78"
                ],
                "text": [
                    "import cv2\n\ntemplate = cv2.imread(\"img/template.png\")\nimg_rot = cv2.imread(\"img/qrcode_rot.png\")\ndef find_corners(img, template):\n  match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n  corner_points = []\n  for i in range(3):\n      _, _, _, max_loc = cv2.minMaxLoc(match_result)\n      x, y = max_loc\n      corner_points.append((x, y))\n      match_result[y-5:y+5, x-5:x+5] = 0\n  return corner_points\n\n\ndef get_rotation(corners):\n# 提取所有x和y坐标值\n  x_values = [p[0] for p in corners]\n  y_values = [p[1] for p in corners]\n  # 排序\n  x_sorted = sorted(x_values)\n  y_sorted = sorted(y_values)\n  # 获取中间值\n  mid_x = x_sorted[1]\n  mid_y = y_sorted[1]\n  # 判断中间值离最小值近还是离最大值近\n  x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n  y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n  if x_close_to_min and y_close_to_min:\n      return 0 # 中间x离最小值近，中间y离最小值近\n  elif x_close_to_min and not y_close_to_min:\n      return 270 # 中间x离最小值近，中间y离最大值近\n  elif not x_close_to_min and y_close_to_min:\n      return 90 # 中间x离最大值近，中间y离最小值近\n  else:\n      return 180 # 中间x离最大值近，中间y离最大值近\ndef rotate_back(img, detected_angle):\n  if detected_angle == 90:\n      return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n  elif detected_angle == 180:\n      return cv2.rotate(img, cv2.ROTATE_180)\n  elif detected_angle == 270:\n      return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n  else:\n      return img\nif __name__==\"__main__\":\n  corners = find_corners(img_rot, template)\n  detected_angle=get_rotation(corners)\n  kidel=rotate_back(img_rot, detected_angle)\n  cv2.imshow(\"林涛\", kidel)\n  cv2.waitKey(0)\n  cv2.destroyAllWindows()"
                ]
            }
        },
        "林西面": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/005b8db565fa456881bc37a51562cd21.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"yinhua.png\")\nimg = cv2.imread(\"yinhua_blur.jpg\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nres2 = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\nmin_val2, max_val2, min_loc2, max_loc2 = cv2.minMaxLoc(res2)\ntop_left2 = max_loc2\nbottom_right2 = (top_left2[0] + w, top_left2[1] + h)\nimgcpy2 = img.copy()\ncv2.rectangle(imgcpy2, top_left2, bottom_right2, (255,0, 0), 2) # 用绿色框\ncv2.imshow(\"imgcpy2\", imgcpy2)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/c1b13f2e5a121665ddac11e25cc155b0.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"puke_t.png\")\nimg = cv2.imread(\"puke.png\")\nh, w = template.shape[:2]#获取模板的宽度与高度\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.1#设置阈值\nloc = np.where(res<=threshold)  #获取匹配位置集合\nfor pt in zip(*loc[::-1]):     #循环标记匹配位置\n    cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"dst\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\n\ntemplate = cv2.imread(\"img/template.png\")\nimg_rot = cv2.imread(\"img/qrcode_rot.png\")\ndef find_corners(img, template):\n# 使用模板匹配,返回匹配度矩阵\n    match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n    # 创建一个列表存储找到的三个角点坐标\n    corner_points = []\n    # 循环找到最大的三个匹配位置\n    for i in range(3):\n        _, _, _, max_loc = cv2.minMaxLoc(match_result)\n        # 将找到的点加入列表\n        x, y = max_loc\n        corner_points.append((x, y))\n        # 将已找到的位置清零,避免重复查找\n        match_result[y-5:y+5, x-5:x+5] = 0\n    return corner_points\n\n\ndef get_rotation(corners):\n# 提取所有x和y坐标值\n    x_values = [p[0] for p in corners]\n    y_values = [p[1] for p in corners]\n    # 排序\n    x_sorted = sorted(x_values)\n    y_sorted = sorted(y_values)\n    # 获取中间值\n    mid_x = x_sorted[1]\n    mid_y = y_sorted[1]\n    # 判断中间值离最小值近还是离最大值近\n    x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n    y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n    if x_close_to_min and y_close_to_min:\n        return 0 # 中间x离最小值近，中间y离最小值近\n    elif x_close_to_min and not y_close_to_min:\n        return 270 # 中间x离最小值近，中间y离最大值近\n    elif not x_close_to_min and y_close_to_min:\n        return 90 # 中间x离最大值近，中间y离最小值近\n    else:\n        return 180 # 中间x离最大值近，中间y离最大值近\ndef rotate_back(img, detected_angle):\n    if detected_angle == 90:\n        return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n    elif detected_angle == 180:\n        return cv2.rotate(img, cv2.ROTATE_180)\n    elif detected_angle == 270:\n        return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n    else:\n        return img\nif __name__==\"__main__\":\n    corners = find_corners(img_rot, template)\n    detected_angle=get_rotation(corners)\n    kidel=rotate_back(img_rot, detected_angle)\n    cv2.imshow(\"ddd\", kidel)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()"
                ]
            }
        },
        "潘易函": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/0884b81a15faa09abb69e6ab46c5fe25.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n#读取模板图像\ntemplate = cv2.imread(\"img/yinhua.png\")\nplt.imshow(template )#显示模板图像\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\n#获取模板的大小（宽度与高度）\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\n# 画出检测到的部分\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"imgcpy\", imgcpy)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/c171b86331ea26f3aea68089d9178939.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]#获取模板的宽度与高度\n#模板匹配过程（采用归一化平方差匹配法，匹配值越接近0，与图像的匹配度越好）\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.02#设置阈值\nloc = np.where(res<=threshold)  #获取匹配位置集合\nfor pt in zip(*loc[::-1]):     #循环标记匹配位置\n    cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 1)\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\ndef Callback(a):\n    threshold = cv2.getTrackbarPos(\"threshold\", windowName) # 获取滑动条的Type值\n    threshold = threshold/100\n    loc = np.where(res <= threshold)\n    imgcpy = img.copy()\n    for pt in zip(*loc[::-1]):\n       cv2.rectangle(imgcpy, pt, (pt[0] + w, pt[1] + h), 255, 5)\n    cv2.imshow(\"PYH\", imgcpy)\nwindowName = \"PYH\" # 窗体名\ncv2.namedWindow(windowName, cv2.WINDOW_AUTOSIZE)\ncv2.imshow(windowName, img)\ncv2.createTrackbar(\"threshold\", windowName, 0, 10, Callback)\ncv2.imshow(\"dst\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\nimport numpy as np\ndef load_images(template_path, image_path):\n    template = cv2.imread(template_path, cv2.IMREAD_GRAYSCALE)\n    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)\n    return template, img\ndef find_qr_corners(img, template):\n    match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n    _, max_val, _, max_loc = cv2.minMaxLoc(match_result)\n    threshold = max_val * 0.8\n    loc = np.where(match_result >= threshold)\n    corners = []\n    for pt in zip(*loc[::-1]):\n        if all(np.linalg.norm(np.array(pt) - np.array(c)) > 10 for c in corners):\n            corners.append(pt)\n            if len(corners) == 3:  # QR码通常需要3个定位点\n                break\n    return corners\ndef calculate_rotation_angle(corners):\n    if len(corners) < 3:\n        return 0\n    center = np.mean(corners, axis=0)\n    angles = []\n    for (x, y) in corners:\n        dx, dy = x - center[0], y - center[1]\n        angles.append(np.degrees(np.arctan2(dy, dx)))\n    avg_angle = np.mean(angles)\n    if avg_angle < -45:\n        return 270\n    elif avg_angle < 45:\n        return 0\n    elif avg_angle < 135:\n        return 90\n    else:\n        return 180\ndef correct_rotation(img, angle):\n    (h, w) = img.shape[:2]\n    center = (w // 2, h // 2)\n    if angle != 0:\n        M = cv2.getRotationMatrix2D(center, angle, 1.0)\n        return cv2.warpAffine(img, M, (w, h))\n    return img\ntemplate, img = load_images(\"img/img/template.png\", \"img/img/qrcode_rot.png\")\ncorners = find_qr_corners(img, template)\nangle = calculate_rotation_angle(corners)\ncorrected_img = correct_rotation(img, angle)\ncv2.imshow(\"img\",img)\ncv2.imshow(\"pyh\", corrected_img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            }
        },
        "王嘉鹏": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/1450b0d2922208f209b27cbf5a6de937.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/yinhua.png\")\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.1\nloc = np.where(res<=threshold)\nfor pt in zip(*loc[::-1]):\n   cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (0,0,255), 2)\ncv2.imshow(\"dst\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/d83fc92b65a01a45adc781d4bd6ae8f7.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.1\nloc = np.where(res<=threshold)\nfor pt in zip(*loc[::-1]):\n cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"dst\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\ntemplate = cv2.imread(\"img/template.png\")\nimg_rot = cv2.imread(\"img/qrcode_rot.png\")\ndef find_corners(img, template):\n  match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n  corner_points = []\n  for i in range(3):\n      _, _, _, max_loc = cv2.minMaxLoc(match_result)\n      x, y = max_loc\n      corner_points.append((x, y))\n      match_result[y-5:y+5, x-5:x+5] = 0\n  return corner_points\ndef get_rotation(corners):\n  x_values = [p[0] for p in corners]\n  y_values = [p[1] for p in corners]\n  x_sorted = sorted(x_values)\n  y_sorted = sorted(y_values)\n  mid_x = x_sorted[1]\n  mid_y = y_sorted[1]\n  x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n  y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n  if x_close_to_min and y_close_to_min:\n      return 0\n  elif x_close_to_min and not y_close_to_min:\n      return 270\n  elif not x_close_to_min and y_close_to_min:\n      return 90\n  else:\n      return 180\ndef rotate_back(img, detected_angle):\n  if detected_angle == 90:\n      return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n  elif detected_angle == 180:\n      return cv2.rotate(img, cv2.ROTATE_180)\n  elif detected_angle == 270:\n      return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n  else:\n      return img\nif __name__==\"__main__\":\n  corners = find_corners(img_rot, template)\n  detected_angle=get_rotation(corners)\n  kidel=rotate_back(img_rot, detected_angle)\n  cv2.imshow(\"ddd\", kidel)\n  cv2.waitKey(0)\n  cv2.destroyAllWindows()"
                ]
            }
        },
        "王家翔": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/0c1623a546727fc34fed445d22dbaf4a.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/yinhua.png\")\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nres2 = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\nmin_val2, max_val2, min_loc2, max_loc2 = cv2.minMaxLoc(res2)\ntop_left2 = max_loc2\nbottom_right2 = (top_left2[0] + w, top_left2[1] + h)\nimgcpy2 = img.copy()\ncv2.rectangle(imgcpy2, top_left2, bottom_right2, (255,0, 0), 2) # 用绿色框\ncv2.imshow(\"WJX\", imgcpy2)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/d86ffa517758cc2bf35fc9dbe926d2e9.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]#获取模板的宽度与高度\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.1#设置阈值\nloc = np.where(res<=threshold)  #获取匹配位置集合\nfor pt in zip(*loc[::-1]):     #循环标记匹配位置\n   cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"wjx\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/4e2539332ae5b730f3cbab417e2a9682.png"
                ],
                "text": [
                    "import cv2\n\ntemplate = cv2.imread(\"img/template.png\")\nimg_rot = cv2.imread(\"img/qrcode_rot.png\")\ndef find_corners(img, template):\n# 使用模板匹配,返回匹配度矩阵\n   match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n   # 创建一个列表存储找到的三个角点坐标\n   corner_points = []\n   # 循环找到最大的三个匹配位置\n   for i in range(3):\n       _, _, _, max_loc = cv2.minMaxLoc(match_result)\n       # 将找到的点加入列表\n       x, y = max_loc\n       corner_points.append((x, y))\n       # 将已找到的位置清零,避免重复查找\n       match_result[y-5:y+5, x-5:x+5] = 0\n   return corner_points\n\n\ndef get_rotation(corners):\n# 提取所有x和y坐标值\n   x_values = [p[0] for p in corners]\n   y_values = [p[1] for p in corners]\n   # 排序\n   x_sorted = sorted(x_values)\n   y_sorted = sorted(y_values)\n   # 获取中间值\n   mid_x = x_sorted[1]\n   mid_y = y_sorted[1]\n   # 判断中间值离最小值近还是离最大值近\n   x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n   y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n   if x_close_to_min and y_close_to_min:\n       return 0 # 中间x离最小值近，中间y离最小值近\n   elif x_close_to_min and not y_close_to_min:\n       return 270 # 中间x离最小值近，中间y离最大值近\n   elif not x_close_to_min and y_close_to_min:\n       return 90 # 中间x离最大值近，中间y离最小值近\n   else:\n       return 180 # 中间x离最大值近，中间y离最大值近\ndef rotate_back(img, detected_angle):\n   if detected_angle == 90:\n       return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n   elif detected_angle == 180:\n       return cv2.rotate(img, cv2.ROTATE_180)\n   elif detected_angle == 270:\n       return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n   else:\n       return img\nif __name__==\"__main__\":\n   corners = find_corners(img_rot, template)\n   detected_angle=get_rotation(corners)\n   kidel=rotate_back(img_rot, detected_angle)\n   cv2.imshow(\"wjx\", kidel)\n   cv2.waitKey(0)\n   cv2.destroyAllWindows()"
                ]
            }
        },
        "王斌": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/e4da6e57483340e767d0e6018f242dae.png"
                ],
                "text": []
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/db6c53bc3c964a3adbb53b586f4af5c0.png"
                ],
                "text": []
            },
            "题目3": {
                "images": [],
                "text": [
                    "mport cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ntemplate = cv2.imread(\"img/template.png\")\nimg_rot = cv2.imread(\"img/qrcode_rot.png\")\nh, w = template.shape[:2]\ndef find_corners(img, template):\n   match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n   corner_points = []\n   for i in range(3):\n       _, _, _, max_loc = cv2.minMaxLoc(match_result)\n       x, y = max_loc\n       corner_points.append((x, y))\n       match_result[y-5:y+5, x-5:x+5] = 0\n   return corner_points\ncorners = find_corners(img_rot, template)\ndef get_rotation(corners):\n   x_values = [p[0] for p in corners]\n   y_values = [p[1] for p in corners]\n   x_sorted = sorted(x_values)\n   y_sorted = sorted(y_values)\n   mid_x = x_sorted[1]\n   mid_y = y_sorted[1]\n   x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n   y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n   if x_close_to_min and y_close_to_min:\n       return 0\n   elif x_close_to_min and not y_close_to_min:\n       return 270\n   elif not x_close_to_min and y_close_to_min:\n       return 90\n   else:\n       return 180\ndef rotate_back(img, detected_angle):\n   if detected_angle == 90:\n       return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n   elif detected_angle == 180:\n       return cv2.rotate(img, cv2.ROTATE_180)\n   elif detected_angle == 270:\n       return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n   else:\n       return img"
                ]
            }
        },
        "王昱诺": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/6207969c5cdf8aaec800cf5aa09136f8.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ntemplate = cv2.imread(\"img/img/yinhua.png\")\nplt.imshow(template)\nimg = cv2.imread(\"img/img/yinhua_blur.jpg\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\n# 画出检测到的部分\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"imgcpy\", imgcpy)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/655e64362f9ca9d73d98861ff90db36b.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/img/puke_t.png\")\nimg = cv2.imread(\"img/img/puke.png\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.009\nloc = np.where(res<=threshold) \nfor pt in zip(*loc[::-1]): \n    cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"dst\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/img/template.png\")\nimg_rot = cv2.imread(\"img/img/qrcode_rot.png\")\ndef find_corners(img, template):\n    # 使用模板匹配,返回匹配度矩阵\n    match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n    # 创建一个列表存储找到的三个角点坐标\n    corner_points = []\n    # 循环找到最大的三个匹配位置\n    for i in range(3):\n        _, _, _, max_loc = cv2.minMaxLoc(match_result)\n        # 将找到的点加入列表\n        x, y = max_loc\n        corner_points.append((x, y))\n        # 将已找到的位置清零,避免重复查找\n        match_result[y-5:y+5, x-5:x+5] = 0\n    return corner_points\ncorners = find_corners(img_rot, template)\ndef get_rotation(corners):\n    # 提取所有x和y坐标值\n    x_values = [p[0] for p in corners]\n    y_values = [p[1] for p in corners]\n    # 排序\n    x_sorted = sorted(x_values)\n    y_sorted = sorted(y_values)\n    # 获取中间值\n    mid_x = x_sorted[1]\n    mid_y = y_sorted[1]\n    # 判断中间值离最小值近还是离最大值近\n    x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n    y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n    if x_close_to_min and y_close_to_min:\n        return 0 # 中间x离最小值近，中间y离最小值近\n    elif x_close_to_min and not y_close_to_min:\n        return 270 # 中间x离最小值近，中间y离最大值近\n    elif not x_close_to_min and y_close_to_min:\n        return 90 # 中间x离最大值近，中间y离最小值近\n    else:\n        return 180 # 中间x离最大值近，中间y离最大值近\n\ndef rotate_back(img, detected_angle):\n    if detected_angle == 90:\n        return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n    elif detected_angle == 180:\n        return cv2.rotate(img, cv2.ROTATE_180)\n    elif detected_angle == 270:\n        return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n    else:\n        return img"
                ]
            }
        },
        "王浩": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/2fd5f86a40cf171604e488fa72331125.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n#读取模板图像\ntemplate = cv2.imread(\"img/yinhua.png\")\nplt.imshow(template )#显示模板图像\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\n#获取模板的大小（宽度与高度）\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\n# 画出检测到的部分\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"wh\", imgcpy)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n# 使用相关系数法（cv2.TM_CCOEFF_NORMED），匹配值越接近1越好\nres2 = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\nmin_val2, max_val2, min_loc2, max_loc2 = cv2.minMaxLoc(res2)\ntop_left2 = max_loc2 # 相关系数法用最大值\nbottom_right2 = (top_left2[0] + w, top_left2[1] + h)\nimgcpy2 = img.copy()\ncv2.rectangle(imgcpy2, top_left2, bottom_right2, (0, 255, 0), 2) # 用绿色框\ncv2.imshow(\"wh\", imgcpy2)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/2884de70a71259d0de6e1233bb85f292.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]#获取模板的宽度与高度\n#模板匹配过程（采用归一化平方差匹配法，匹配值越接近0，与图像的匹配度越好）\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.01#设置阈值\nloc = np.where(res<=threshold)  #获取匹配位置集合\nfor pt in zip(*loc[::-1]):     #循环标记匹配位置\n    cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"wh\",img)\n\n\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\ndef Callback(a):\n    threshold = cv2.getTrackbarPos(\"threshold\", windowName) # 获取滑动条的Type值\n    threshold = threshold/100\n    loc = np.where(res <= threshold)\n    imgcpy = img.copy()\n    for pt in zip(*loc[::-1]):\n       cv2.rectangle(imgcpy, pt, (pt[0] + w, pt[1] + h), 255, 5)\n    cv2.imshow(\"wh\", imgcpy)\nwindowName = \"wh2\" # 窗体名\ncv2.namedWindow(windowName, cv2.WINDOW_AUTOSIZE)\ncv2.imshow(windowName, img)\ncv2.createTrackbar(\"threshold\", windowName, 0, 10, Callback)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\n\ndef find_corners(img, template):\n    # 使用模板匹配,返回匹配度矩阵\n    match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n    # 创建一个列表存储找到的三个角点坐标\n    corner_points = []\n    # 循环找到最大的三个匹配位置\n    for i in range(3):\n        _, _, _, max_loc = cv2.minMaxLoc(match_result)\n        # 将找到的点加入列表\n        x, y = max_loc\n        corner_points.append((x, y))\n        # 将已找到的位置清零,避免重复查找\n        match_result[y-5:y+5, x-5:x+5] = 0\n    return corner_points\n\n\ndef get_rotation(corners):\n    # 提取所有x和y坐标值\n    x_values = [p[0] for p in corners]\n    y_values = [p[1] for p in corners]\n    # 排序\n    x_sorted = sorted(x_values)\n    y_sorted = sorted(y_values)\n    # 获取中间值\n    mid_x = x_sorted[1]\n    mid_y = y_sorted[1]\n    # 判断中间值离最小值近还是离最大值近\n    x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n    y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n    # 根据中间值位置判断旋转角度\n    if x_close_to_min and y_close_to_min:\n        return 0  # 中间x离最小值近，中间y离最小值近\n    elif x_close_to_min and not y_close_to_min:\n        return 270  # 中间x离最小值近，中间y离最大值近\n    elif not x_close_to_min and y_close_to_min:\n        return 90  # 中间x离最大值近，中间y离最小值近\n    else:\n        return 180  # 中间x离最大值近，中间y离最大值近\ndef rotate_back(img, detected_angle):\n    if detected_angle == 90:\n        return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n    elif detected_angle == 180:\n        return cv2.rotate(img, cv2.ROTATE_180)\n    elif detected_angle == 270:\n        return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n    else:\n        return img\nimg_rot=cv2.imread('img/qrcode_rot.png')\ntemplate=cv2.imread('img/template.png')\ncorners = find_corners(img_rot, template)\nget_rotation=get_rotation(corners)\nimg=rotate_back(img_rot,get_rotation)\ncv2.imshow('wh',img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            }
        },
        "王钰洁": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/30d6a78427287efce36096685d0b5923.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n#读取模板图像\ntemplate = cv2.imread(\"img/yinhua.png\")\nplt.imshow(template )#显示模板图像\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\n#获取模板的大小（宽度与高度）\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\n# 画出检测到的部分\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"imgwyj\", imgcpy)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/750_1024/3d51ac6537b63cfa29c168005c80e21a.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/img/puke_t.png\")\nimg = cv2.imread(\"img/img/puke.png\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.009\nloc = np.where(res<=threshold)\nfor pt in zip(*loc[::-1]):\ncv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"dst\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\n\ndef find_corners(img, template):\n    # 使用模板匹配,返回匹配度矩阵\n    match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n    # 创建一个列表存储找到的三个角点坐标\n    corner_points = []\n    # 循环找到最大的三个匹配位置\n    for i in range(3):\n        _, _, _, max_loc = cv2.minMaxLoc(match_result)\n        # 将找到的点加入列表\n        x, y = max_loc\n        corner_points.append((x, y))\n        # 将已找到的位置清零,避免重复查找\n        match_result[y-5:y+5, x-5:x+5] = 0\n    return corner_points\n\n\ndef get_rotation(corners):\n    # 提取所有x和y坐标值\n    x_values = [p[0] for p in corners]\n    y_values = [p[1] for p in corners]\n    # 排序\n    x_sorted = sorted(x_values)\n    y_sorted = sorted(y_values)\n    # 获取中间值\n    mid_x = x_sorted[1]\n    mid_y = y_sorted[1]\n    # 判断中间值离最小值近还是离最大值近\n    x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n    y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n    # 根据中间值位置判断旋转角度\n    if x_close_to_min and y_close_to_min:\n        return 0  # 中间x离最小值近，中间y离最小值近\n    elif x_close_to_min and not y_close_to_min:\n        return 270  # 中间x离最小值近，中间y离最大值近\n    elif not x_close_to_min and y_close_to_min:\n        return 90  # 中间x离最大值近，中间y离最小值近\n    else:\n        return 180  # 中间x离最大值近，中间y离最大值近\ndef rotate_back(img, detected_angle):\n    if detected_angle == 90:\n        return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n    elif detected_angle == 180:\n        return cv2.rotate(img, cv2.ROTATE_180)\n    elif detected_angle == 270:\n        return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n    else:\n        return img\nimg_rot=cv2.imread('img/qrcode_rot.png')\ntemplate=cv2.imread('img/template.png')\ncorners = find_corners(img_rot, template)\nget_rotation=get_rotation(corners)\nimg=rotate_back(img_rot,get_rotation)\ncv2.imshow('wyj',img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            }
        },
        "葛人欢": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/2a41a2a7f520b8aa81ef36914629b342.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n#读取模板图像\ntemplate = cv2.imread(\"img/yinhua.png\")\nplt.imshow(template )#显示模板图像\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\n#获取模板的大小（宽度与高度）\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\n# 画出检测到的部分\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"grh\", imgcpy)\n# 使用相关系数法（cv2.TM_CCOEFF_NORMED），匹配值越接近1越好\nres2 = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\nmin_val2, max_val2, min_loc2, max_loc2 = cv2.minMaxLoc(res2)\ntop_left2 = max_loc2 # 相关系数法用最大值\nbottom_right2 = (top_left2[0] + w, top_left2[1] + h)\nimgcpy2 = img.copy()\ncv2.rectangle(imgcpy2, top_left2, bottom_right2, (0, 255, 0), 2) # 用绿色框\ncv2.imshow(\"grh1\", imgcpy2)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/483512cf4b195ace4d622f3b384c091a.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]#获取模板的宽度与高度\n#模板匹配过程（采用归一化平方差匹配法，匹配值越接近0，与图像的匹配度越好）\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.1#设置阈值\nloc = np.where(res<=threshold)  #获取匹配位置集合\nfor pt in zip(*loc[::-1]):     #循环标记匹配位置\n    cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"grh\",img)\n\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\ndef Callback(a):\n    threshold = cv2.getTrackbarPos(\"threshold\", windowName) # 获取滑动条的Type值\n    threshold = threshold/100\n    loc = np.where(res <= threshold)\n    imgcpy = img.copy()\n    for pt in zip(*loc[::-1]):\n       cv2.rectangle(imgcpy, pt, (pt[0] + w, pt[1] + h), 255, 5)\n    cv2.imshow(\"grh\", imgcpy)\nwindowName = \"grh\" # 窗体名\ncv2.namedWindow(windowName, cv2.WINDOW_AUTOSIZE)\ncv2.imshow(windowName, img)\ncv2.createTrackbar(\"threshold\", windowName, 0, 10, Callback)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/8648b864f0252e8dd67045ac18c41f6f.png"
                ],
                "text": [
                    "import cv2\n\ndef find_corners(img, template):\n    # 使用模板匹配,返回匹配度矩阵\n    match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n    # 创建一个列表存储找到的三个角点坐标\n    corner_points = []\n    # 循环找到最大的三个匹配位置\n    for i in range(3):\n        _, _, _, max_loc = cv2.minMaxLoc(match_result)\n        # 将找到的点加入列表\n        x, y = max_loc\n        corner_points.append((x, y))\n        # 将已找到的位置清零,避免重复查找\n        match_result[y-5:y+5, x-5:x+5] = 0\n    return corner_points\n\n\ndef get_rotation(corners):\n    # 提取所有x和y坐标值\n    x_values = [p[0] for p in corners]\n    y_values = [p[1] for p in corners]\n    # 排序\n    x_sorted = sorted(x_values)\n    y_sorted = sorted(y_values)\n    # 获取中间值\n    mid_x = x_sorted[1]\n    mid_y = y_sorted[1]\n    # 判断中间值离最小值近还是离最大值近\n    x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n    y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n    # 根据中间值位置判断旋转角度\n    if x_close_to_min and y_close_to_min:\n        return 0  # 中间x离最小值近，中间y离最小值近\n    elif x_close_to_min and not y_close_to_min:\n        return 270  # 中间x离最小值近，中间y离最大值近\n    elif not x_close_to_min and y_close_to_min:\n        return 90  # 中间x离最大值近，中间y离最小值近\n    else:\n        return 180  # 中间x离最大值近，中间y离最大值近\ndef rotate_back(img, detected_angle):\n    if detected_angle == 90:\n        return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n    elif detected_angle == 180:\n        return cv2.rotate(img, cv2.ROTATE_180)\n    elif detected_angle == 270:\n        return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n    else:\n        return img\nimg_rot=cv2.imread('img/qrcode_rot.png')\ntemplate=cv2.imread('img/template.png')\ncorners = find_corners(img_rot, template)\nget_rotation=get_rotation(corners)\nimg=rotate_back(img_rot,get_rotation)\ncv2.imshow('grh',img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            }
        },
        "蒋子豪": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/443b07beef69ba0e0bec8d1e9a989dae.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n#读取模板图像\ntemplate = cv2.imread(\"img/yinhua.png\")\nplt.imshow(template )#显示模板图像\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\n#获取模板的大小（宽度与高度）\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\n# 画出检测到的部分\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"jzh\", imgcpy)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/ffab78d69ff407d5fb89b13a31fe1c1b.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]#获取模板的宽度与高度\n#模板匹配过程（采用归一化平方差匹配法，匹配值越接近0，与图像的匹配度越好）\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.1#设置阈值\nloc = np.where(res<=threshold)  #获取匹配位置集合\nfor pt in zip(*loc[::-1]):     #循环标记匹配位置\n    cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"jzh\",img)\n\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\ndef Callback(a):\n    threshold = cv2.getTrackbarPos(\"threshold\", windowName) # 获取滑动条的Type值\n    threshold = threshold/100\n    loc = np.where(res <= threshold)\n    imgcpy = img.copy()\n    for pt in zip(*loc[::-1]):\n       cv2.rectangle(imgcpy, pt, (pt[0] + w, pt[1] + h), 255, 5)\n    cv2.imshow(\"jzh\", imgcpy)\nwindowName = \"jzh\" # 窗体名\ncv2.namedWindow(windowName, cv2.WINDOW_AUTOSIZE)\ncv2.imshow(windowName, img)\ncv2.createTrackbar(\"threshold\", windowName, 0, 10, Callback)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/0b07b210e9138d358ff137b4be7bbaaa.png"
                ],
                "text": [
                    "import cv2\n\ndef find_corners(img, template):\n    # 使用模板匹配,返回匹配度矩阵\n    match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n    # 创建一个列表存储找到的三个角点坐标\n    corner_points = []\n    # 循环找到最大的三个匹配位置\n    for i in range(3):\n        _, _, _, max_loc = cv2.minMaxLoc(match_result)\n        # 将找到的点加入列表\n        x, y = max_loc\n        corner_points.append((x, y))\n        # 将已找到的位置清零,避免重复查找\n        match_result[y-5:y+5, x-5:x+5] = 0\n    return corner_points\n\n\ndef get_rotation(corners):\n    # 提取所有x和y坐标值\n    x_values = [p[0] for p in corners]\n    y_values = [p[1] for p in corners]\n    # 排序\n    x_sorted = sorted(x_values)\n    y_sorted = sorted(y_values)\n    # 获取中间值\n    mid_x = x_sorted[1]\n    mid_y = y_sorted[1]\n    # 判断中间值离最小值近还是离最大值近\n    x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n    y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n    # 根据中间值位置判断旋转角度\n    if x_close_to_min and y_close_to_min:\n        return 0  # 中间x离最小值近，中间y离最小值近\n    elif x_close_to_min and not y_close_to_min:\n        return 270  # 中间x离最小值近，中间y离最大值近\n    elif not x_close_to_min and y_close_to_min:\n        return 90  # 中间x离最大值近，中间y离最小值近\n    else:\n        return 180  # 中间x离最大值近，中间y离最大值近\ndef rotate_back(img, detected_angle):\n    if detected_angle == 90:\n        return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n    elif detected_angle == 180:\n        return cv2.rotate(img, cv2.ROTATE_180)\n    elif detected_angle == 270:\n        return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n    else:\n        return img\nimg_rot=cv2.imread('img/qrcode_rot.png')\ntemplate=cv2.imread('img/template.png')\ncorners = find_corners(img_rot, template)\nget_rotation=get_rotation(corners)\nimg=rotate_back(img_rot,get_rotation)\ncv2.imshow('jzh',img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            }
        },
        "蔡雨轩": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/25faeb1bf2079b46ff0a0e3985ed7a86.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n#读取模板图像\ntemplate = cv2.imread(\"img/yinhua.png\")\nplt.imshow(template )#显示模板图像\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\n#获取模板的大小（宽度与高度）\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\n# 画出检测到的部分\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"cyx\", imgcpy)\n# 使用相关系数法（cv2.TM_CCOEFF_NORMED），匹配值越接近1越好\nres2 = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\nmin_val2, max_val2, min_loc2, max_loc2 = cv2.minMaxLoc(res2)\ntop_left2 = max_loc2 # 相关系数法用最大值\nbottom_right2 = (top_left2[0] + w, top_left2[1] + h)\nimgcpy2 = img.copy()\ncv2.rectangle(imgcpy2, top_left2, bottom_right2, (0, 255, 0), 2) # 用绿色框\ncv2.imshow(\"cyx1\", imgcpy2)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/1c46f8e72d1980fe9c0c7cc7fc0cc3b7.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]#获取模板的宽度与高度\n#模板匹配过程（采用归一化平方差匹配法，匹配值越接近0，与图像的匹配度越好）\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.1#设置阈值\nloc = np.where(res<=threshold)  #获取匹配位置集合\nfor pt in zip(*loc[::-1]):     #循环标记匹配位置\n   cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"cyx\",img)\n\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\ndef Callback(a):\n   threshold = cv2.getTrackbarPos(\"threshold\", windowName) # 获取滑动条的Type值\n   threshold = threshold/100\n   loc = np.where(res <= threshold)\n   imgcpy = img.copy()\n   for pt in zip(*loc[::-1]):\n      cv2.rectangle(imgcpy, pt, (pt[0] + w, pt[1] + h), 255, 5)\n   cv2.imshow(\"cyx\", imgcpy)\nwindowName = \"cyx\" # 窗体名\ncv2.namedWindow(windowName, cv2.WINDOW_AUTOSIZE)\ncv2.imshow(windowName, img)\ncv2.createTrackbar(\"threshold\", windowName, 0, 10, Callback)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/09081ee6a3dc0ee795dad7841e35bf55.png"
                ],
                "text": [
                    "import cv2\n\ndef find_corners(img, template):\n   # 使用模板匹配,返回匹配度矩阵\n   match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n   # 创建一个列表存储找到的三个角点坐标\n   corner_points = []\n   # 循环找到最大的三个匹配位置\n   for i in range(3):\n       _, _, _, max_loc = cv2.minMaxLoc(match_result)\n       # 将找到的点加入列表\n       x, y = max_loc\n       corner_points.append((x, y))\n       # 将已找到的位置清零,避免重复查找\n       match_result[y-5:y+5, x-5:x+5] = 0\n   return corner_points\n\n\ndef get_rotation(corners):\n   # 提取所有x和y坐标值\n   x_values = [p[0] for p in corners]\n   y_values = [p[1] for p in corners]\n   # 排序\n   x_sorted = sorted(x_values)\n   y_sorted = sorted(y_values)\n   # 获取中间值\n   mid_x = x_sorted[1]\n   mid_y = y_sorted[1]\n   # 判断中间值离最小值近还是离最大值近\n   x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n   y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n   # 根据中间值位置判断旋转角度\n   if x_close_to_min and y_close_to_min:\n       return 0  # 中间x离最小值近，中间y离最小值近\n   elif x_close_to_min and not y_close_to_min:\n       return 270  # 中间x离最小值近，中间y离最大值近\n   elif not x_close_to_min and y_close_to_min:\n       return 90  # 中间x离最大值近，中间y离最小值近\n   else:\n       return 180  # 中间x离最大值近，中间y离最大值近\ndef rotate_back(img, detected_angle):\n   if detected_angle == 90:\n       return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n   elif detected_angle == 180:\n       return cv2.rotate(img, cv2.ROTATE_180)\n   elif detected_angle == 270:\n       return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n   else:\n       return img\nimg_rot=cv2.imread('img/qrcode_rot.png')\ntemplate=cv2.imread('img/template.png')\ncorners = find_corners(img_rot, template)\nget_rotation=get_rotation(corners)\nimg=rotate_back(img_rot,get_rotation)\ncv2.imshow('cyx',img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            }
        },
        "薛凯": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/fc6006ed1e78a6344ac8ca14673fd22b.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n#读取模板图像\ntemplate = cv2.imread(\"img/yinhua.png\")\nplt.imshow(template )#显示模板图像\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\n#获取模板的大小（宽度与高度）\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\n# 画出检测到的部分\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"xk\", imgcpy)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/b4279c71c5f9a7a2dd55c763401c6545.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]#获取模板的宽度与高度\n#模板匹配过程（采用归一化平方差匹配法，匹配值越接近0，与图像的匹配度越好）\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.01#设置阈值\nloc = np.where(res<=threshold)  #获取匹配位置集合\nfor pt in zip(*loc[::-1]):     #循环标记匹配位置\n   cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"xk\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\ndef find_corners(img, template):\nmatch_result = cv2.matchTemplate('img/qrcode_rot.png',template, cv2.TM_CCOEFF_NORMED)\n# 创建一个列表存储找到的三个角点坐标\ncorner_points = []\n# 循环找到最大的三个匹配位置\nfor i in range(3):\n_, _, _, max_loc = cv2.minMaxLoc(match_result)\n# 将找到的点加入列表\nx, y = max_loc\ncorner_points.append((x, y))\n# 将已找到的位置清零,避免重复查找\nmatch_result[y-5:y+5, x-5:x+5] = 0\nreturn corner_points\ncorners = find_corners(img_rot, template)\ndef get_rotation(corners):\n# 提取所有x和y坐标值\nx_values = [p[0] for p in corners]\ny_values = [p[1] for p in corners]\n# 排序\nx_sorted = sorted(x_values)\ny_sorted = sorted(y_values)\n# 获取中间值\nmid_x = x_sorted[1]\nmid_y = y_sorted[1]\n# 判断中间值离最小值近还是离最大值近\nx_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\ny_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n# 根据中间值位置判断旋转角度\nif x_close_to_min and y_close_to_min:\nreturn 0 # 中间x离最小值近，中间y离最小值近\nelif x_close_to_min and not y_close_to_min:\nreturn 270 # 中间x离最小值近，中间y离最大值近\nelif not x_close_to_min and y_close_to_min:\nreturn 90 # 中间x离最大值近，中间y离最小值近\nelse:\nreturn 180 # 中间x离最大值近，中间y离最大值近\ndef rotate_back(img, detected_angle):\nif detected_angle == 90:\n   return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\nelif detected_angle == 180:\n   return cv2.rotate(img, cv2.ROTATE_180)\nelif detected_angle == 270:\n   return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\nelse:\n   return img"
                ]
            }
        },
        "许贤明": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/a7f24eb637a21bb0ce8b1e6fad949356.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n#读取模板图像\ntemplate = cv2.imread(\"sucai/yinhua.png\")\nplt.imshow(template )#显示模板图像\nimg = cv2.imread(\"sucai/yinhua_blur.jpg\")\n#获取模板的大小（宽度与高度）\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\n# 画出检测到的部分\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"imgcpy\", imgcpy)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/e508d1f70939e0b099b879e3ad576c01.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"sucai/puke_t.png\")\nimg = cv2.imread(\"sucai/puke.png\")\nh, w = template.shape[:2]#获取模板的宽度与高度\n#模板匹配过程（采用归一化平方差匹配法，匹配值越接近0，与图像的匹配度越好）\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\ndef Callback(a):\n    threshold = cv2.getTrackbarPos(\"threshold\", windowName) # 获取滑动条的Type值\n    threshold = threshold/100\n    loc = np.where(res <= threshold)\n    imgcpy = img.copy()\n    for pt in zip(*loc[::-1]):\n       cv2.rectangle(imgcpy, pt, (pt[0] + w, pt[1] + h), 255, 5)\n    cv2.imshow(\"xxm\", imgcpy)\nwindowName = \"xxm\" # 窗体名\ncv2.namedWindow(windowName, cv2.WINDOW_AUTOSIZE)\ncv2.imshow(windowName, img)\ncv2.createTrackbar(\"threshold\", windowName, 0, 10, Callback)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": []
            }
        },
        "赖志和": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/2d64be57e48d2f7986a21c2de23dffd8.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n#读取模板图像\ntemplate = cv2.imread(\"img/yinhua.png\")\nplt.imshow(template )#显示模板图像\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\n#获取模板的大小（宽度与高度）\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\n# 画出检测到的部分\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"lzh\", imgcpy)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/652836d37071b0149cb96f9d90c28139.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]#获取模板的宽度与高度\n#模板匹配过程（采用归一化平方差匹配法，匹配值越接近0，与图像的匹配度越好）\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.01#设置阈值\nloc = np.where(res<=threshold)  #获取匹配位置集合\nfor pt in zip(*loc[::-1]):     #循环标记匹配位置\n    cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"lzh\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\ndef find_corners(img, template):\nmatch_result = cv2.matchTemplate('img/qrcode_rot.png',template, cv2.TM_CCOEFF_NORMED)\n# 创建一个列表存储找到的三个角点坐标\ncorner_points = []\n# 循环找到最大的三个匹配位置\nfor i in range(3):\n_, _, _, max_loc = cv2.minMaxLoc(match_result)\n# 将找到的点加入列表\nx, y = max_loc\ncorner_points.append((x, y))\n# 将已找到的位置清零,避免重复查找\nmatch_result[y-5:y+5, x-5:x+5] = 0\nreturn corner_points\ncorners = find_corners(img_rot, template)\ndef get_rotation(corners):\n# 提取所有x和y坐标值\nx_values = [p[0] for p in corners]\ny_values = [p[1] for p in corners]\n# 排序\nx_sorted = sorted(x_values)\ny_sorted = sorted(y_values)\n# 获取中间值\nmid_x = x_sorted[1]\nmid_y = y_sorted[1]\n# 判断中间值离最小值近还是离最大值近\nx_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\ny_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n# 根据中间值位置判断旋转角度\nif x_close_to_min and y_close_to_min:\nreturn 0 # 中间x离最小值近，中间y离最小值近\nelif x_close_to_min and not y_close_to_min:\nreturn 270 # 中间x离最小值近，中间y离最大值近\nelif not x_close_to_min and y_close_to_min:\nreturn 90 # 中间x离最大值近，中间y离最小值近\nelse:\nreturn 180 # 中间x离最大值近，中间y离最大值近\ndef rotate_back(img, detected_angle):\nif detected_angle == 90:\n    return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\nelif detected_angle == 180:\n    return cv2.rotate(img, cv2.ROTATE_180)\nelif detected_angle == 270:\n    return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\nelse:\n    return img"
                ]
            }
        },
        "邱伊琳": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/750_1024/2f59ce2c32ab3a873456fd8f2c514b01.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\ntemplate = cv2.imread(\"img/img/yinhua.png\")\nplt.imshow(template)\nimg = cv2.imread(\"img/img/yinhua_blur.jpg\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\n# 画出检测到的部分\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"imgcpy\", imgcpy)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/750_1024/19b5fa53449f89a86085c802edc9b190.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/img/puke_t.png\")\nimg = cv2.imread(\"img/img/puke.png\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.009\nloc = np.where(res<=threshold)\nfor pt in zip(*loc[::-1]):\ncv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"dst\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\nimport cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/img/puke_t.png\")\nimg = cv2.imread(\"img/img/puke.png\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.009\nloc = np.where(res<=threshold)\nfor pt in zip(*loc[::-1]):\ncv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"dst\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\nimport cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/img/puke_t.png\")\nimg = cv2.imread(\"img/img/puke.png\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.009\nloc = np.where(res<=threshold)\nfor pt in zip(*loc[::-1]):\ncv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"dst\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/img/template.png\")\nimg_rot = cv2.imread(\"img/img/qrcode_rot.png\")\ndef find_corners(img, template):\n# 使用模板匹配,返回匹配度矩阵\nmatch_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n# 创建一个列表存储找到的三个角点坐标\ncorner_points = []\n# 循环找到最大的三个匹配位置\nfor i in range(3):\n_, _, _, max_loc = cv2.minMaxLoc(match_result)\n# 将找到的点加入列表\nx, y = max_loc\ncorner_points.append((x, y))\n# 将已找到的位置清零,避免重复查找\nmatch_result[y-5:y+5, x-5:x+5] = 0\nreturn corner_points\ncorners = find_corners(img_rot, template)\ndef get_rotation(corners):\n# 提取所有x和y坐标值\nx_values = [p[0] for p in corners]\ny_values = [p[1] for p in corners]\n# 排序\nx_sorted = sorted(x_values)\ny_sorted = sorted(y_values)\n# 获取中间值\nmid_x = x_sorted[1]\nmid_y = y_sorted[1]\n# 判断中间值离最小值近还是离最大值近\nx_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\ny_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\nif x_close_to_min and y_close_to_min:\nreturn 0 # 中间x离最小值近，中间y离最小值近\nelif x_close_to_min and not y_close_to_min:\nreturn 270 # 中间x离最小值近，中间y离最大值近\nelif not x_close_to_min and y_close_to_min:\nreturn 90 # 中间x离最大值近，中间y离最小值近\nelse:\nreturn 180 # 中间x离最大值近，中间y离最大值近\ndef rotate_back(img, detected_angle):\nif detected_angle == 90:\nreturn cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\nelif detected_angle == 180:\nreturn cv2.rotate(img, cv2.ROTATE_180)\nelif detected_angle == 270:\nreturn cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\nelse:\nreturn img"
                ]
            }
        },
        "郑光甫": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/4284587dfd218797e62c7ffcdf45fd48.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ntemplate = cv2.imread(\"img/img/yinhua.png\")\nplt.imshow(template )\nimg = cv2.imread(\"img/img/yinhua_blur.jpg\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"zgf\", imgcpy)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/fb5b73da17a6f8c4bec1084919e02187.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\n\ntemplate = cv2.imread(\"img/img/puke_t.png\")\nimg = cv2.imread(\"img/img/puke.png\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\ndef Callback(a):\n    threshold = cv2.getTrackbarPos(\"threshold\", windowName) \n    threshold = threshold/100\n    loc = np.where(res <= threshold)\n    imgcpy = img.copy()\n    for pt in zip(*loc[::-1]):\n       cv2.rectangle(imgcpy, pt, (pt[0] + w, pt[1] + h), 255, 5)\n    cv2.imshow(\"zgf\", imgcpy)\nwindowName = \"zgf\"\ncv2.namedWindow(windowName, cv2.WINDOW_AUTOSIZE)\ncv2.imshow(windowName, img)\ncv2.createTrackbar(\"threshold\", windowName, 0, 10, Callback)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\nimport numpy as np\n\ntemplate1 = cv2.imread(\"img/img/template.png\")\nimg_rot = cv2.imread(\"img/img/qrcode_rot.png\")\ndef find_corners(img, template):\n\n   match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n   corner_points = []\n   for i in range(3):\n      _, _, _, max_loc = cv2.minMaxLoc(match_result)\n      x, y = max_loc\n      corner_points.append((x, y))\n      match_result[y-5:y+5, x-5:x+5] = 0\n   return corner_points\n\ncorners = find_corners(img_rot, template1)\n\ndef get_rotation(corners):\n    x_values = [p[0] for p in corners]\n    y_values = [p[1] for p in corners]\n    x_sorted = sorted(x_values)\n    y_sorted = sorted(y_values)\n    mid_x = x_sorted[1]\n    mid_y = y_sorted[1]\n    x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n    y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n    if x_close_to_min and y_close_to_min:\n        return 0\n    elif x_close_to_min and not y_close_to_min:\n        return 270\n    elif not x_close_to_min and y_close_to_min:\n         return 90\n    else:\n         return 180\n\ndef rotate_back(img, detected_angle):\n     if detected_angle == 90:\n      return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n     elif detected_angle == 180:\n      return cv2.rotate(img, cv2.ROTATE_180)\n     elif detected_angle == 270:\n      return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n     else:\n      return img"
                ]
            }
        },
        "郭捷瑞": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/dfcec8805042e6258aba52267503aec6.PNG"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nyinhua = cv2.imread('yinhua.png', 0)\nyinhua_blur = cv2.imread('yinhua_blur.jpg', 0)\nresult = cv2.matchTemplate(yinhua_blur, yinhua, cv2.TM_CCOEFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\nh, w = yinhua.shape\ntop_left = max_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\nmatched_img = cv2.cvtColor(yinhua_blur, cv2.COLOR_GRAY2BGR)\ncv2.rectangle(matched_img, top_left, bottom_right, (0, 255, 0), 2)\ncv2.imwrite('img/matched_result.png', matched_img)"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/2ce6cc40fe4aa8f08fc221f9cdae4821.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nthresh = 80\nimg = None\nt = None\nresult = None\ndef update_thresh(val):\n    global thresh, img, t, result\n    thresh = val / 100.0\n    res = cv2.matchTemplate(img, t, cv2.TM_CCOEFF_NORMED)\n    loc = np.where(res >= thresh)\n    result = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)\n    for pt in zip(*loc[::-1]):\n        cv2.rectangle(result, pt, (pt[0] + t.shape[1], pt[1] + t.shape[0]), (255, 0, 0), 2)\n    cv2.imshow('NLH', result)\n    print(f\"当前阈值: {thresh:.2f}\")\ndef main():\n    global img, t, result\n    t = cv2.imread('img/puke_t.png', 0)\n    img = cv2.imread('img/puke.png', 0)\n\n    if img is None or t is None:\n        print(\"错误：图片未找到！请检查路径。\")\n        return\n    cv2.namedWindow('NLH')\n    cv2.createTrackbar('Threshold', 'NLH', thresh, 100, update_thresh)\n    update_thresh(thresh)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()\nif __name__ == \"__main__\":\n    main()"
                ]
            },
            "题目3": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/5257fc6acfac7b6158cc4eccea2e4c72.png"
                ],
                "text": [
                    "import cv2\ntemplate = cv2.imread(\"img/template.png\")\nimg_rot = cv2.imread(\"img/qrcode_rot.png\")\ndef find_corners(img, template):\n   match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n   corner_points = []\n   for i in range(3):\n       _, _, _, max_loc = cv2.minMaxLoc(match_result)\n       x, y = max_loc\n       corner_points.append((x, y))\n       match_result[y-5:y+5, x-5:x+5] = 0\n   return corner_points\ndef get_rotation(corners):\n   x_values = [p[0] for p in corners]\n   y_values = [p[1] for p in corners]\n   x_sorted = sorted(x_values)\n   y_sorted = sorted(y_values)\n   mid_x = x_sorted[1]\n   mid_y = y_sorted[1]\n   x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n   y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n   if x_close_to_min and y_close_to_min:\n       return 0\n   elif x_close_to_min and not y_close_to_min:\n       return 270\n   elif not x_close_to_min and y_close_to_min:\n       return 90\n   else:\n       return 180\ndef rotate_back(img, detected_angle):\n   if detected_angle == 90:\n       return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n   elif detected_angle == 180:\n       return cv2.rotate(img, cv2.ROTATE_180)\n   elif detected_angle == 270:\n       return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n   else:\n       return img\nif __name__==\"__main__\":\n   corners = find_corners(img_rot, template)\n   detected_angle=get_rotation(corners)\n   kidel=rotate_back(img_rot, detected_angle)\n   cv2.imshow(\"GJR\", kidel)\n   cv2.waitKey(0)\n   cv2.destroyAllWindows()"
                ]
            }
        },
        "金孝华": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/be17fdca98684b87328da3686e137cfc.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\ntemplate = cv2.imread(\"img/yinhua.png\")\nplt.imshow(template )\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"jxh\", imgcpy)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\nres2 = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\nmin_val2, max_val2, min_loc2, max_loc2 = cv2.minMaxLoc(res2)\ntop_left2 = max_loc2 \nbottom_right2 = (top_left2[0] + w, top_left2[1] + h)\nimgcpy2 = img.copy()\ncv2.rectangle(imgcpy2, top_left2, bottom_right2, (0, 255, 0), 2) # 用绿色框\ncv2.imshow(\"imgcpy2\", imgcpy2)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/d4896e77f6fdc76c56582242f41326d7.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]\ncv2.namedWindow('JXH')\ndef on_trackbar(val):\n    threshold = val / 1000.0 \n    img_result = img.copy() \n    res = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\n    loc = np.where(res <= threshold)\n    for pt in zip(*loc[::-1]):\n        cv2.rectangle(img_result, pt, (pt[0] + w, pt[1] + h), (255, 0, 0), 1)\n    cv2.imshow('jxh', img_result)\n\ncv2.createTrackbar('Threshold', 'JXH', 30, 100, on_trackbar)\non_trackbar(30)  \n\nwhile True:\n    key = cv2.waitKey(1)\n    if key == 27: \n        break\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/5aed92718a3200d18fcb13b2fc6d3d8f.png"
                ],
                "text": [
                    "import cv2\n\n\ndef find_corners(img, template):\n    match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n    corner_points = []\n   \n    for i in range(3):\n        _, _, _, max_loc = cv2.minMaxLoc(match_result)\n        x, y = max_loc\n        corner_points.append((x, y))\n        match_result[y - 5:y + 5, x - 5:x + 5] = 0\n    return corner_points\n\ndef get_rotation(corners):\n\n    x_values = [p[0] for p in corners]\n    y_values = [p[1] for p in corners]\n\n    x_sorted = sorted(x_values)\n    y_sorted = sorted(y_values)\n\n    mid_x = x_sorted[1]\n    mid_y = y_sorted[1]\n\n    x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n    y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n\n\n    if x_close_to_min and y_close_to_min:\n        return 0 \n    elif x_close_to_min and not y_close_to_min:\n        return 270 \n    elif not x_close_to_min and y_close_to_min:\n        return 90  \n    else:\n        return 180  \n\n\ndef rotate_back(img, detected_angle):\n    if detected_angle == 90:\n        return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n    elif detected_angle == 180:\n        return cv2.rotate(img, cv2.ROTATE_180)\n    elif detected_angle == 270:\n        return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n    else:\n        return img\n\n\nif __name__ == \"__main__\":\n    \n    img_rot = cv2.imread('img/qrcode_rot.png', 0)  # 以灰度模式读取\n    template = cv2.imread('img/template.png', 0)  # 以灰度模式读取\n\n    corners = find_corners(img_rot, template)\n    detected_angle = get_rotation(corners)\n    corrected_img = rotate_back(img_rot, detected_angle)\n\n    print(f\"Detected rotation angle: {detected_angle} degrees\")\n    cv2.imshow('mistake Image', img_rot)\n    cv2.imshow('corrected Image', corrected_img)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()\n    cv2.imwrite('corrected_image.jpg', corrected_img)"
                ]
            }
        },
        "陈沈祺": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/488662161ffd992353328e94396769fb.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ntemplate = cv2.imread(\"img/yinhua.png\")\nplt.imshow(template )#显示模板图像\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\n#获取模板的大小（宽度与高度）\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\n# 画出检测到的部分\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"wh\", imgcpy)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n# 使用相关系数法（cv2.TM_CCOEFF_NORMED），匹配值越接近1越好\nres2 = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\nmin_val2, max_val2, min_loc2, max_loc2 = cv2.minMaxLoc(res2)\ntop_left2 = max_loc2 # 相关系数法用最大值\nbottom_right2 = (top_left2[0] + w, top_left2[1] + h)\nimgcpy2 = img.copy()\ncv2.rectangle(imgcpy2, top_left2, bottom_right2, (0, 255, 0), 2) # 用绿色框\ncv2.imshow(\"wh\", imgcpy2)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]#获取模板的宽度与高度\n#模板匹配过程（采用归一化平方差匹配法，匹配值越接近0，与图像的匹配度越好）\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.01#设置阈值\nloc = np.where(res<=threshold)  #获取匹配位置集合\nfor pt in zip(*loc[::-1]):     #循环标记匹配位置\n   cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"wh\",img)\n\n\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\ndef Callback(a):\n   threshold = cv2.getTrackbarPos(\"threshold\", windowName) # 获取滑动条的Type值\n   threshold = threshold/100\n   loc = np.where(res <= threshold)\n   imgcpy = img.copy()\n   for pt in zip(*loc[::-1]):\n      cv2.rectangle(imgcpy, pt, (pt[0] + w, pt[1] + h), 255, 5)\n   cv2.imshow(\"wh\", imgcpy)\nwindowName = \"wh2\" # 窗体名\ncv2.namedWindow(windowName, cv2.WINDOW_AUTOSIZE)\ncv2.imshow(windowName, img)\ncv2.createTrackbar(\"threshold\", windowName, 0, 10, Callback)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\n\ndef find_corners(img, template):\n   # 使用模板匹配,返回匹配度矩阵\n   match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n   # 创建一个列表存储找到的三个角点坐标\n   corner_points = []\n   # 循环找到最大的三个匹配位置\n   for i in range(3):\n       _, _, _, max_loc = cv2.minMaxLoc(match_result)\n       # 将找到的点加入列表\n       x, y = max_loc\n       corner_points.append((x, y))\n       # 将已找到的位置清零,避免重复查找\n       match_result[y-5:y+5, x-5:x+5] = 0\n   return corner_points\n\n\ndef get_rotation(corners):\n   # 提取所有x和y坐标值\n   x_values = [p[0] for p in corners]\n   y_values = [p[1] for p in corners]\n   # 排序\n   x_sorted = sorted(x_values)\n   y_sorted = sorted(y_values)\n   # 获取中间值\n   mid_x = x_sorted[1]\n   mid_y = y_sorted[1]\n   # 判断中间值离最小值近还是离最大值近\n   x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n   y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n   # 根据中间值位置判断旋转角度\n   if x_close_to_min and y_close_to_min:\n       return 0  # 中间x离最小值近，中间y离最小值近\n   elif x_close_to_min and not y_close_to_min:\n       return 270  # 中间x离最小值近，中间y离最大值近\n   elif not x_close_to_min and y_close_to_min:\n       return 90  # 中间x离最大值近，中间y离最小值近\n   else:\n       return 180  # 中间x离最大值近，中间y离最大值近\ndef rotate_back(img, detected_angle):\n   if detected_angle == 90:\n       return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n   elif detected_angle == 180:\n       return cv2.rotate(img, cv2.ROTATE_180)\n   elif detected_angle == 270:\n       return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n   else:\n       return img\nimg_rot=cv2.imread('img/qrcode_rot.png')\ntemplate=cv2.imread('img/template.png')\ncorners = find_corners(img_rot, template)\nget_rotation=get_rotation(corners)\nimg=rotate_back(img_rot,get_rotation)\ncv2.imshow('wh',img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            }
        },
        "陈泽宇": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/6dd56ab9cbbae9d641f2f7b2e1b15363.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n#读取模板图像\ntemplate = cv2.imread(\"img/yinhua.png\")\nplt.imshow(template )#显示模板图像\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\n#获取模板的大小（宽度与高度）\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\n# 画出检测到的部分\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"czy\", imgcpy)\n# 使用相关系数法（cv2.TM_CCOEFF_NORMED），匹配值越接近1越好\nres2 = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\nmin_val2, max_val2, min_loc2, max_loc2 = cv2.minMaxLoc(res2)\ntop_left2 = max_loc2 # 相关系数法用最大值\nbottom_right2 = (top_left2[0] + w, top_left2[1] + h)\nimgcpy2 = img.copy()\ncv2.rectangle(imgcpy2, top_left2, bottom_right2, (0, 255, 0), 2) # 用绿色框\ncv2.imshow(\"czy1\", imgcpy2)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/495f3acd29d0311a83bb896becadbbd0.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]#获取模板的宽度与高度\n#模板匹配过程（采用归一化平方差匹配法，匹配值越接近0，与图像的匹配度越好）\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.1#设置阈值\nloc = np.where(res<=threshold)  #获取匹配位置集合\nfor pt in zip(*loc[::-1]):     #循环标记匹配位置\n   cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"czy\",img)\n\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\ndef Callback(a):\n   threshold = cv2.getTrackbarPos(\"threshold\", windowName) # 获取滑动条的Type值\n   threshold = threshold/100\n   loc = np.where(res <= threshold)\n   imgcpy = img.copy()\n   for pt in zip(*loc[::-1]):\n      cv2.rectangle(imgcpy, pt, (pt[0] + w, pt[1] + h), 255, 5)\n   cv2.imshow(\"czy\", imgcpy)\nwindowName = \"czy\" # 窗体名\ncv2.namedWindow(windowName, cv2.WINDOW_AUTOSIZE)\ncv2.imshow(windowName, img)\ncv2.createTrackbar(\"threshold\", windowName, 0, 10, Callback)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/bb95e8c386f6b5da6cba3c828429de24.png"
                ],
                "text": [
                    "import cv2\n\ndef find_corners(img, template):\n   # 使用模板匹配,返回匹配度矩阵\n   match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n   # 创建一个列表存储找到的三个角点坐标\n   corner_points = []\n   # 循环找到最大的三个匹配位置\n   for i in range(3):\n       _, _, _, max_loc = cv2.minMaxLoc(match_result)\n       # 将找到的点加入列表\n       x, y = max_loc\n       corner_points.append((x, y))\n       # 将已找到的位置清零,避免重复查找\n       match_result[y-5:y+5, x-5:x+5] = 0\n   return corner_points\n\n\ndef get_rotation(corners):\n   # 提取所有x和y坐标值\n   x_values = [p[0] for p in corners]\n   y_values = [p[1] for p in corners]\n   # 排序\n   x_sorted = sorted(x_values)\n   y_sorted = sorted(y_values)\n   # 获取中间值\n   mid_x = x_sorted[1]\n   mid_y = y_sorted[1]\n   # 判断中间值离最小值近还是离最大值近\n   x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n   y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n   # 根据中间值位置判断旋转角度\n   if x_close_to_min and y_close_to_min:\n       return 0  # 中间x离最小值近，中间y离最小值近\n   elif x_close_to_min and not y_close_to_min:\n       return 270  # 中间x离最小值近，中间y离最大值近\n   elif not x_close_to_min and y_close_to_min:\n       return 90  # 中间x离最大值近，中间y离最小值近\n   else:\n       return 180  # 中间x离最大值近，中间y离最大值近\ndef rotate_back(img, detected_angle):\n   if detected_angle == 90:\n       return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n   elif detected_angle == 180:\n       return cv2.rotate(img, cv2.ROTATE_180)\n   elif detected_angle == 270:\n       return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n   else:\n       return img\nimg_rot=cv2.imread('img/qrcode_rot.png')\ntemplate=cv2.imread('img/template.png')\ncorners = find_corners(img_rot, template)\nget_rotation=get_rotation(corners)\nimg=rotate_back(img_rot,get_rotation)\ncv2.imshow('czy',img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            }
        },
        "陈豪": {
            "题目1": {
                "images": [],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n#读取模板图像\ntemplate = cv2.imread(\"img/yinhua.png\")\nplt.imshow(template )#显示模板图像\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\n#获取模板的大小（宽度与高度）\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\n# 画出检测到的部分\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"xyd\", imgcpy)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n# 使用相关系数法（cv2.TM_CCOEFF_NORMED），匹配值越接近1越好\nres2 = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\nmin_val2, max_val2, min_loc2, max_loc2 = cv2.minMaxLoc(res2)\ntop_left2 = max_loc2 # 相关系数法用最大值\nbottom_right2 = (top_left2[0] + w, top_left2[1] + h)\nimgcpy2 = img.copy()\ncv2.rectangle(imgcpy2, top_left2, bottom_right2, (0, 255, 0), 2) # 用绿色框\ncv2.imshow(\"xyd\", imgcpy2)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]#获取模板的宽度与高度\n#模板匹配过程（采用归一化平方差匹配法，匹配值越接近0，与图像的匹配度越好）\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.01#设置阈值\nloc = np.where(res<=threshold)  #获取匹配位置集合\nfor pt in zip(*loc[::-1]):     #循环标记匹配位置\n   cv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"xyd\",img)\n\n\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\ndef Callback(a):\n   threshold = cv2.getTrackbarPos(\"threshold\", windowName) # 获取滑动条的Type值\n   threshold = threshold/100\n   loc = np.where(res <= threshold)\n   imgcpy = img.copy()\n   for pt in zip(*loc[::-1]):\n      cv2.rectangle(imgcpy, pt, (pt[0] + w, pt[1] + h), 255, 5)\n   cv2.imshow(\"xyd\", imgcpy)\nwindowName = \"xyd2\" # 窗体名\ncv2.namedWindow(windowName, cv2.WINDOW_AUTOSIZE)\ncv2.imshow(windowName, img)\ncv2.createTrackbar(\"threshold\", windowName, 0, 10, Callback)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\n\ndef find_corners(img, template):\n   # 使用模板匹配,返回匹配度矩阵\n   match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n   # 创建一个列表存储找到的三个角点坐标\n   corner_points = []\n   # 循环找到最大的三个匹配位置\n   for i in range(3):\n       _, _, _, max_loc = cv2.minMaxLoc(match_result)\n       # 将找到的点加入列表\n       x, y = max_loc\n       corner_points.append((x, y))\n       # 将已找到的位置清零,避免重复查找\n       match_result[y-5:y+5, x-5:x+5] = 0\n   return corner_points\n\n\ndef get_rotation(corners):\n   # 提取所有x和y坐标值\n   x_values = [p[0] for p in corners]\n   y_values = [p[1] for p in corners]\n   # 排序\n   x_sorted = sorted(x_values)\n   y_sorted = sorted(y_values)\n   # 获取中间值\n   mid_x = x_sorted[1]\n   mid_y = y_sorted[1]\n   # 判断中间值离最小值近还是离最大值近\n   x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n   y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n   # 根据中间值位置判断旋转角度\n   if x_close_to_min and y_close_to_min:\n       return 0  # 中间x离最小值近，中间y离最小值近\n   elif x_close_to_min and not y_close_to_min:\n       return 270  # 中间x离最小值近，中间y离最大值近\n   elif not x_close_to_min and y_close_to_min:\n       return 90  # 中间x离最大值近，中间y离最小值近\n   else:\n       return 180  # 中间x离最大值近，中间y离最大值近\ndef rotate_back(img, detected_angle):\n   if detected_angle == 90:\n       return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n   elif detected_angle == 180:\n       return cv2.rotate(img, cv2.ROTATE_180)\n   elif detected_angle == 270:\n       return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n   else:\n       return img\nimg_rot=cv2.imread('img/qrcode_rot.png')\ntemplate=cv2.imread('img/template.png')\ncorners = find_corners(img_rot, template)\nget_rotation=get_rotation(corners)\nimg=rotate_back(img_rot,get_rotation)\ncv2.imshow('wh',img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            }
        },
        "韩哲涛": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/b40293dd0a4dd71767b9c87bcad511f4"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/yinhua.png\")\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.1\nloc = np.where(res<=threshold)\nfor pt in zip(*loc[::-1]):\ncv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (0,0,255), 2)\ncv2.imshow(\"dst\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/7e9efeaa77316b581d37e8e5dc1cada6"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.1\nloc = np.where(res<=threshold)\nfor pt in zip(*loc[::-1]):\ncv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"dst\",img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "🧸:\n[图片]\n🧸:\nimport cv2\ntemplate = cv2.imread(\"img/template.png\")\nimg_rot = cv2.imread(\"img/qrcode_rot.png\")\ndef find_corners(img, template):\nmatch_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\ncorner_points = []\nfor i in range(3):\n_, _, _, max_loc = cv2.minMaxLoc(match_result)\nx, y = max_loc\ncorner_points.append((x, y))\nmatch_result[y-5:y+5, x-5:x+5] = 0\nreturn corner_points\ndef get_rotation(corners):\nx_values = [p[0] for p in corners]\ny_values = [p[1] for p in corners]\nx_sorted = sorted(x_values)\ny_sorted = sorted(y_values)\nmid_x = x_sorted[1]\nmid_y = y_sorted[1]\nx_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\ny_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\nif x_close_to_min and y_close_to_min:\nreturn 0\nelif x_close_to_min and not y_close_to_min:\nreturn 270\nelif not x_close_to_min and y_close_to_min:\nreturn 90\nelse:\nreturn 180\ndef rotate_back(img, detected_angle):\nif detected_angle == 90:\nreturn cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\nelif detected_angle == 180:\nreturn cv2.rotate(img, cv2.ROTATE_180)\nelif detected_angle == 270:\nreturn cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\nelse:\nreturn img\nif __name__==\"__main__\":\ncorners = find_corners(img_rot, template)\ndetected_angle=get_rotation(corners)\nkidel=rotate_back(img_rot, detected_angle)\ncv2.imshow(\"ddd\", kidel)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            }
        },
        "高嘉泽": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/5a43817f1317670ffa32b30908be7cae.png"
                ],
                "text": []
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/073b7f87f6a0f5586e2f2e49516c2b92.png"
                ],
                "text": []
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\n\ndef find_corners(img, template):\n    # 使用模板匹配,返回匹配度矩阵\n    match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n    # 创建一个列表存储找到的三个角点坐标\n    corner_points = []\n    # 循环找到最大的三个匹配位置\n    for i in range(3):\n        _, _, _, max_loc = cv2.minMaxLoc(match_result)\n        # 将找到的点加入列表\n        x, y = max_loc\n        corner_points.append((x, y))\n        # 将已找到的位置清零,避免重复查找\n        match_result[y-5:y+5, x-5:x+5] = 0\n    return corner_points\n\n\ndef get_rotation(corners):\n    # 提取所有x和y坐标值\n    x_values = [p[0] for p in corners]\n    y_values = [p[1] for p in corners]\n    # 排序\n    x_sorted = sorted(x_values)\n    y_sorted = sorted(y_values)\n    # 获取中间值\n    mid_x = x_sorted[1]\n    mid_y = y_sorted[1]\n    # 判断中间值离最小值近还是离最大值近\n    x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n    y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n    # 根据中间值位置判断旋转角度\n    if x_close_to_min and y_close_to_min:\n        return 0  # 中间x离最小值近，中间y离最小值近\n    elif x_close_to_min and not y_close_to_min:\n        return 270  # 中间x离最小值近，中间y离最大值近\n    elif not x_close_to_min and y_close_to_min:\n        return 90  # 中间x离最大值近，中间y离最小值近\n    else:\n        return 180  # 中间x离最大值近，中间y离最大值近\ndef rotate_back(img, detected_angle):\n    if detected_angle == 90:\n        return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n    elif detected_angle == 180:\n        return cv2.rotate(img, cv2.ROTATE_180)\n    elif detected_angle == 270:\n        return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n    else:\n        return img\nimg_rot=cv2.imread('img/qrcode_rot.png')\ntemplate=cv2.imread('img/template.png')\ncorners = find_corners(img_rot, template)\nget_rotation=get_rotation(corners)\nimg=rotate_back(img_rot,get_rotation)\ncv2.imshow('gjz',img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            }
        },
        "黄君健": {
            "题目1": {
                "images": [],
                "text": [
                    "import numpy as np\nimport matplotlib.pyplot as plt\ntemplate = cv2.imread(\"img/yinhua.png\")\nplt.imshow(template )#显示模板图像\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\n#获取模板的大小（宽度与高度）\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\n# 画出检测到的部分\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"wh\", imgcpy)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n# 使用相关系数法（cv2.TM_CCOEFF_NORMED），匹配值越接近1越好\nres2 = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\nmin_val2, max_val2, min_loc2, max_loc2 = cv2.minMaxLoc(res2)\ntop_left2 = max_loc2 # 相关系数法用最大值\nbottom_right2 = (top_left2[0] + w, top_left2[1] + h)\nimgcpy2 = img.copy()\ncv2.rectangle(imgcpy2, top_left2, bottom_right2, (0, 255, 0), 2) # 用绿色框\ncv2.imshow(\"wh\", imgcpy2)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/puke_t.png\")\nimg = cv2.imread(\"img/puke.png\")\nh, w = template.shape[:2]#获取模板的宽度与高度\n#模板匹配过程（采用归一化平方差匹配法，匹配值越接近0，与图像的匹配度越好）\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.01#设置阈值\nloc = np.where(res<=threshold)  #获取匹配位置集合\nfor pt in zip(*loc[::-1]):     #循环标记匹配位置\ncv2.rectangle(img, pt, (pt[0] + w, pt[1] + h), (255,0,0), 2)\ncv2.imshow(\"wh\",img)\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\ndef Callback(a):\nthreshold = cv2.getTrackbarPos(\"threshold\", windowName) # 获取滑动条的Type值\nthreshold = threshold/100\nloc = np.where(res <= threshold)\nimgcpy = img.copy()\nfor pt in zip(*loc[::-1]):\ncv2.rectangle(imgcpy, pt, (pt[0] + w, pt[1] + h), 255, 5)\ncv2.imshow(\"wh\", imgcpy)\nwindowName = \"wh2\" # 窗体名\ncv2.namedWindow(windowName, cv2.WINDOW_AUTOSIZE)\ncv2.imshow(windowName, img)\ncv2.createTrackbar(\"threshold\", windowName, 0, 10, Callback)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [],
                "text": [
                    "import cv2\ndef find_corners(img, template):\n# 使用模板匹配,返回匹配度矩阵\nmatch_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n# 创建一个列表存储找到的三个角点坐标\ncorner_points = []\n# 循环找到最大的三个匹配位置\nfor i in range(3):\n_, _, _, max_loc = cv2.minMaxLoc(match_result)\n# 将找到的点加入列表\nx, y = max_loc\ncorner_points.append((x, y))\n# 将已找到的位置清零,避免重复查找\nmatch_result[y-5:y+5, x-5:x+5] = 0\nreturn corner_points\ndef get_rotation(corners):\n# 提取所有x和y坐标值\nx_values = [p[0] for p in corners]\ny_values = [p[1] for p in corners]\n# 排序\nx_sorted = sorted(x_values)\ny_sorted = sorted(y_values)\n# 获取中间值\nmid_x = x_sorted[1]\nmid_y = y_sorted[1]\n# 判断中间值离最小值近还是离最大值近\nx_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\ny_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n# 根据中间值位置判断旋转角度\nif x_close_to_min and y_close_to_min:\nreturn 0  # 中间x离最小值近，中间y离最小值近\nelif x_close_to_min and not y_close_to_min:\nreturn 270  # 中间x离最小值近，中间y离最大值近\nelif not x_close_to_min and y_close_to_min:\nreturn 90  # 中间x离最大值近，中间y离最小值近\nelse:\nreturn 180  # 中间x离最大值近，中间y离最大值近\ndef rotate_back(img, detected_angle):\nif detected_angle == 90:\nreturn cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\nelif detected_angle == 180:\nreturn cv2.rotate(img, cv2.ROTATE_180)\nelif detected_angle == 270:\nreturn cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\nelse:\nreturn img\nimg_rot=cv2.imread('img/qrcode_rot.png')\ntemplate=cv2.imread('img/template.png')\ncorners = find_corners(img_rot, template)\nget_rotation=get_rotation(corners)\nimg=rotate_back(img_rot,get_rotation)\ncv2.imshow('wh',img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            }
        },
        "黄塨燚": {
            "题目1": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/f6306e91690d70c740fd8a1f0f91ede5.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n#读取模板图像\ntemplate = cv2.imread(\"img/yinhua.png\")\nplt.imshow(template )#显示模板图像\nimg = cv2.imread(\"img/yinhua_blur.jpg\")\n#获取模板的大小（宽度与高度）\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\n# 画出检测到的部分\nimgcpy = img.copy()\ncv2.rectangle(imgcpy, top_left, bottom_right, 255, 2)\ncv2.imshow(\"hgy\", imgcpy)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目2": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/cd1e192d4c66d104de0b02334fdafe79.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ntemplate = cv2.imread(\"img/img/puke_t.png\")\nimg = cv2.imread(\"img/img/puke.png\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nthreshold = 0.01\nloc = np.where(res <= threshold)\nimg_draw = img.copy()\nfor pt in zip(*loc[::-1]):\n    cv2.rectangle(img_draw, pt, (pt[0]+w, pt[1]+h), (255,0,0), 1)\ndef Callback(a):\n    threshold = cv2.getTrackbarPos(\"threshold\", windowName)/100\n    loc = np.where(res <= threshold)\n    imgcpy = img.copy()\n    for pt in zip(*loc[::-1]):\n        cv2.rectangle(imgcpy, pt, (pt[0]+w, pt[1]+h), (255,0,0), 2)\n    cv2.imshow(windowName, imgcpy)\nwindowName = \"hgy\"\ncv2.namedWindow(windowName, cv2.WINDOW_AUTOSIZE)\ncv2.imshow(windowName, img_draw)\ncv2.createTrackbar(\"threshold\", windowName, 1, 100, Callback)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            },
            "题目3": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/df4c6c8f0b39baf86f9fa2608fc918df.png"
                ],
                "text": [
                    "import cv2\nimport numpy as np\ndef load_images(template_path, image_path):\n    template = cv2.imread(template_path, cv2.IMREAD_GRAYSCALE)\n    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)\n    return template, img\ndef find_qr_corners(img, template):\n    match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n    _, max_val, _, max_loc = cv2.minMaxLoc(match_result)\n    threshold = max_val * 0.8\n    loc = np.where(match_result >= threshold)\n    corners = []\n    for pt in zip(*loc[::-1]):\n        if all(np.linalg.norm(np.array(pt) - np.array(c)) > 10 for c in corners):\n            corners.append(pt)\n            if len(corners) == 3:  # QR码通常需要3个定位点\n                break\n    return corners\ndef calculate_rotation_angle(corners):\n    if len(corners) < 3:\n        return 0\n    center = np.mean(corners, axis=0)\n    angles = []\n    for (x, y) in corners:\n        dx, dy = x - center[0], y - center[1]\n        angles.append(np.degrees(np.arctan2(dy, dx)))\n    avg_angle = np.mean(angles)\n    if avg_angle < -45:\n        return 270\n    elif avg_angle < 45:\n        return 0\n    elif avg_angle < 135:\n        return 90\n    else:\n        return 180\ndef correct_rotation(img, angle):\n    (h, w) = img.shape[:2]\n    center = (w // 2, h // 2)\n    if angle != 0:\n        M = cv2.getRotationMatrix2D(center, angle, 1.0)\n        return cv2.warpAffine(img, M, (w, h))\n    return img\ntemplate, img = load_images(\"img/img/template.png\", \"img/img/qrcode_rot.png\")\ncorners = find_qr_corners(img, template)\nangle = calculate_rotation_angle(corners)\ncorrected_img = correct_rotation(img, angle)\ncv2.imshow(\"img\",img)\ncv2.imshow(\"hgy\", corrected_img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()"
                ]
            }
        }
    },
    "题目": {
        "题目1": {
            "正确答案": "正确答案：\nimport cv2\n# 读取模板图片\ntemplate = cv2.imread(\"./img/yinhua.png\")\nimg = cv2.imread(\"./img/yinhua_blur.jpg\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\ntop_left = min_loc\nbottom_right = (top_left[0] + w, top_left[1] + h)\n# 画出检测到的部分\ncv2.rectangle(img, top_left, bottom_right, 255, 2)\ncv2.imshow(\"JXJ\", img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()",
            "题干": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/4cb1f60bd6c3be52df4240e40b1a8fcf.png"
                ],
                "text": [
                    "下载附件并解压，读取img文件夹下的\"yinhua、yinhua_blur\"。\n- 在yinhua_blur上检测出yinhua所在的区域并截图\n截图参考："
                ]
            }
        },
        "题目2": {
            "正确答案": "正确答案：\nimport cv2\nimport numpy as np\ntemplate = cv2.imread(\"./img/puke_t.png\")\nimg = cv2.imread(\"./imgpuke.png\")\nh, w = template.shape[:2]\nres = cv2.matchTemplate(img, template, cv2.TM_SQDIFF_NORMED)\n\ndef Callback(a):\n    threshold = cv2.getTrackbarPos(\"threshold\", windowName)  # 获取滑动条的Type值\n    threshold = threshold/100\n    loc = np.where(res <= threshold)\n    imgcpy = img.copy()\n    for pt in zip(*loc[::-1]):\n        cv2.rectangle(imgcpy, pt, (pt[0] + w, pt[1] + h), 255, 5)\n    cv2.imshow(\"JXJ\", imgcpy)\n\nwindowName = \"JXJ\"  # 窗体名\ncv2.namedWindow(windowName, cv2.WINDOW_AUTOSIZE)\ncv2.imshow(windowName, img)\ncv2.createTrackbar(\"threshold\", windowName, 0, 10, Callback)\ncv2.waitKey(0)\ncv2.destroyAllWindows()",
            "题干": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/2133af1b8b505ca71570c93e1c0fb07d.png"
                ],
                "text": [
                    "读取img文件夹下的\"puke_t、puke\"。\n- 在puke上检测出所有puke_t所在的区域并截图\n- 设置滑块调整阈值来选择所有puke_t所在的区域\n截图参考："
                ]
            }
        },
        "题目3": {
            "正确答案": "正确答案：\nimport cv2\nimport numpy as np\nimport random\n\nimg_qr = cv2.imread('qrcode.png')\ntemplate = cv2.imread('template.png')\n\n# 用模板匹配找三个角落\ndef find_corners(img, template):\n    # 使用模板匹配,返回匹配度矩阵\n    match_result = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)\n    # 创建一个列表存储找到的三个角点坐标\n    corner_points = []\n    # 循环找到最大的三个匹配位置\n    for i in range(3):\n        # 找到当前最大值的位置\n        _, _, _, max_loc = cv2.minMaxLoc(match_result)\n        # 将找到的点加入列表\n        x, y = max_loc\n        corner_points.append((x, y))\n        # 将已找到的位置清零,避免重复查找\n        match_result[y-5:y+5, x-5:x+5] = 0\n    return corner_points\n\ncorners = find_corners(img_rot, template)\n\ndef get_rotation(corners):\n    # 提取所有x和y坐标值\n    x_values = [p[0] for p in corners]\n    y_values = [p[1] for p in corners]\n    # 排序\n    x_sorted = sorted(x_values)\n    y_sorted = sorted(y_values)\n    # 获取中间值\n    mid_x = x_sorted[1]\n    mid_y = y_sorted[1]\n    # 判断中间值离最小值近还是离最大值近\n    x_close_to_min = (mid_x - x_sorted[0]) < (x_sorted[2] - mid_x)\n    y_close_to_min = (mid_y - y_sorted[0]) < (y_sorted[2] - mid_y)\n    # 根据中间值位置判断旋转角度\n    if x_close_to_min and y_close_to_min:\n        return 0  # 中间x离最小值近，中间y离最小值近\n    elif x_close_to_min and not y_close_to_min:\n        return 270  # 中间x离最小值近，中间y离最大值近\n    elif not x_close_to_min and y_close_to_min:\n        return 90    # 中间x离最大值近，中间y离最小值近\n    else:\n        return 180   # 中间x离最大值近，中间y离最大值近\n\ndetected_angle = get_rotation(corners)\n\n\ndef rotate_back(img, detected_angle):\n    if detected_angle == 90:\n        return cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n    elif detected_angle == 180:\n        return cv2.rotate(img, cv2.ROTATE_180)\n    elif detected_angle == 270:\n        return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n    else:\n        return img\n\nimg_corrected = rotate_back(img_rot, detected_angle)\ncv2.imshow('img_corrected', img_corrected)\ncv2.waitKey(0)\ncv2.destroyAllWindows()",
            "题干": {
                "images": [
                    "https://p.ananas.chaoxing.com/star3/origin/a9e985a9d24460fc093f8e76c4aaa602.png"
                ],
                "text": [
                    "读取img文件夹下的\"qrcode_rot、template\"。\n- 用template检查qrcode_rot的三个点的坐标\n- 根据坐标判断图像被选择了多少度\n- 将图像转回去\n只需要提交代码就行，回正的图像如下所示："
                ]
            }
        }
    }
}